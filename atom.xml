<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnailDev&#39;s Blog</title>
  
  <subtitle>简单不想写，太难不会写。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://snaildev.github.io/"/>
  <updated>2018-10-03T13:59:11.917Z</updated>
  <id>https://snaildev.github.io/</id>
  
  <author>
    <name>SnailDev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springBoot实战（二）web综合开发</title>
    <link href="https://snaildev.github.io/article/spring-springboot-web.html"/>
    <id>https://snaildev.github.io/article/spring-springboot-web.html</id>
    <published>2018-09-02T12:36:41.000Z</published>
    <updated>2018-10-03T13:59:11.917Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/spring-springboot-1.jpg" alt="spring-springboot-web"></p><p>Spring Boot Web开发非常的简单，其中包括常用的json输出、filters、property、log等。<a id="more"></a></p><h2 id="接口开发"><a href="#接口开发" class="headerlink" title="接口开发"></a>接口开发</h2><p>在以前的spring开发的时候需要我们提供json接口的时候需要做以下配置：</p><ol><li>添加jackon等相关jar包</li><li>配置spring controller扫描</li><li>对接的方法添加@ResponseBody</li></ol><p>就这样我们会经常由于配置问题，导致406错误等等，那么spring boot是如何做的呢，只需要给Controller类添加<code>@RestController</code> 注解即可，那么默认类中的方法都会以json的格式返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getUser"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"snaildev"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果我们需要使用页面开发只要使用<code>@Controller</code>，下面会结合模板来说明。</p><h2 id="自定义Filter"><a href="#自定义Filter" class="headerlink" title="自定义Filter"></a>自定义Filter</h2><p>我们常常在项目中会使用filters用于记录调用日志、排除有XSS威胁的字符、执行权限验证等等。Spring Boot自动添加了OrderedCharacterEncodingFilter和HiddenHttpMethodFilter,并且我们可以自定义Filter。</p><p>两个步骤：</p><ol><li>实现Filter接口，实现Filter方法；</li><li>添加<code>@Configuration</code> 注解，将自定义的Filter加入过滤链；</li></ol><p>ok，直接上代码</p><p>WebConfiguration.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RemoteIpFilter <span class="title">remoteIpFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RemoteIpFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">filterRegistrationBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">        registrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        registrationBean.addInitParameter(<span class="string">"paramName"</span>,<span class="string">"paramValue"</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">"MyFilter"</span>);</span><br><span class="line">        registrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>MyFilter.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        System.out.println(<span class="string">"this is MyFilter，url："</span> + request.getRequestURI());</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="自定义Property"><a href="#自定义Property" class="headerlink" title="自定义Property"></a>自定义Property</h2><p>在Web开发中，我们经常需要自定义一些配置文件，如何使用呢?</p><p><strong>配置在application.properties中</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.title=SnailDev&apos;s Blog</span><br><span class="line">com.example.description=Coding is everything in my life.</span><br></pre></td></tr></table></figure><p></p><p>自定义配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleProperties</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;com.example.title&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;com.example.description&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略getter settet方法</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>log配置</strong> 配置输出的地址和输出的级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging.path=/user/local/log</span><br><span class="line">logging.level.com.example=DEBUG</span><br><span class="line">logging.level.org.springframework.web=INFO</span><br><span class="line">logging.level.org.hibernate=ERROR</span><br></pre></td></tr></table></figure><p></p><p>path为本机log地址，logging.level 后面可以根据包路径配置不同资源的log级别</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><p>在这里我们重点来看一下mysql、spring data jpa的使用，其中mysql就不用说了，大家应该都很熟悉，jpa是利用Hibernate生成各种自动化的sql，如果只是简单的增删改查，基本上不用手写了，spring 内部已经帮我们封装实现了。</p><p>下面简单介绍一下如何在spring boot中简单使用</p><h3 id="1-添加相关的jar包依赖"><a href="#1-添加相关的jar包依赖" class="headerlink" title="1. 添加相关的jar包依赖"></a>1. 添加相关的jar包依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-添加配置文件"><a href="#2-添加配置文件" class="headerlink" title="2. 添加配置文件"></a>2. 添加配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/test</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br><span class="line">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span><br><span class="line">spring.jpa.show-sql=true</span><br></pre></td></tr></table></figure><p>其实这个hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构，有四个值：</p><ol><li>create：每次加载hibernate时都会删除上一次生成的表，然后根据model类再重新生成新表，哪怕两次没有任何改变也会这样执行，这就是导致数据库数据丢失的一个重要原因。</li><li>create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭，表就自动删除。</li><li>update：最常用的属性，第一次加载hibernate时根据model类会自动建立表的结构（数据库先建好），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会被删除。要留意的是当部署到服务器后，表结构是不会被马上建立ilai的，是要等应用第一次运行起来后才会。</li><li>validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</li></ol><p><code>dialect</code> 主要是指定生成表名的存储引擎为InneoDB <code>show-sql</code> 是否打印出自动生成的SQL,方便调试的时候查看</p><h3 id="3-添加实体类和Dao"><a href="#3-添加实体类和Dao" class="headerlink" title="3. 添加实体类和Dao"></a>3. 添加实体类和Dao</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>, unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">true</span>, unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String regTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略getter settet方法、构造方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dao只要继承JpaRepository类就可以，几乎可以不用写方法，还有一个特别的功能非常赞，就是根据方法名来自动生成SQL,比如<code>findByUserName</code>，会自动产生一个以<code>userName</code>为参数的查询方法，再比如<code>findAll</code>就会查询表里面的所有数据，再比如自动分页等等。</p><p><strong>Entity中不映射成列的字段得加@Transient注解，不加注解就会映射成列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">findByUserNameOrEmail</span><span class="params">(String userName,String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG);</span><br><span class="line">        String formattedDate = dateFormat.format(date);</span><br><span class="line"></span><br><span class="line">        userRepository.save(<span class="keyword">new</span> User(<span class="string">"aa1"</span>, <span class="string">"aa@gmail.com"</span>, <span class="string">"aa"</span>, <span class="string">"aa123456"</span>, formattedDate));</span><br><span class="line">        userRepository.save(<span class="keyword">new</span> User(<span class="string">"bb1"</span>, <span class="string">"bb@gmail.com"</span>, <span class="string">"bb"</span>, <span class="string">"bb123456"</span>, formattedDate));</span><br><span class="line">        userRepository.save(<span class="keyword">new</span> User(<span class="string">"cc1"</span>, <span class="string">"cc@gmail.com"</span>, <span class="string">"cc"</span>, <span class="string">"cc123456"</span>, formattedDate));</span><br><span class="line"></span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>,userRepository.findAll().size());</span><br><span class="line">        Assert.assertEquals(<span class="string">"bb"</span>,userRepository.findByUserNameOrEmail(<span class="string">"bb"</span>,<span class="string">"bb@gmail.com"</span>).getNickName());</span><br><span class="line">        userRepository.delete(userRepository.findByUserName(<span class="string">"aa1"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然spring data jpa还有很多功能，比如封装好的分页，可以自定义SQL，主从分离等等，等到以后再做细讲。</p><h2 id="Thymeleaf模板"><a href="#Thymeleaf模板" class="headerlink" title="Thymeleaf模板"></a>Thymeleaf模板</h2><p>Spring Boot推荐使用thymeleaf模板来代替jpa,那么thymeleaf模板到底好在哪里呢，让Spring官方来推荐，下面我们来看看</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMarker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，<strong>Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用</strong>。</p><p>好了，你们可能会觉得已经习惯使用了velocity,freemarker,beetle之类的模板，那么thymeleaf到底好在哪呢？让我们来做个对比： Thymeleaf是与众不同的，因为它使用了自然的模板技术。这意味着Thymeleaf的模板语法并不会破坏文档的结构，模板依旧是有效的XML文档。模板还可以用作工作原型，Thymeleaf会在运行期替换掉静态值。Velocity与FreeMarker则是连续的文本处理器。</p><p>下面的代码示例分别使用Velocity、FreeMarker与Thymeleaf打印出一条消息：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Velocity: <span class="tag">&lt;<span class="name">p</span>&gt;</span>$message<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">FreeMarker: <span class="tag">&lt;<span class="name">p</span>&gt;</span>$&#123;message&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">Thymeleaf: <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;message&#125;"</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>注意，由于Thymeleaf使用了XML DOM解析器，因此它并不适合处理大规模的XML文件。</strong></p><h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p><strong>URL</strong></p><p>URL在Web应用模板中占据着十分重要的地位，需要特别注意 的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。Thymeleaf支持绝对路径URL:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;https://www.baidu.com&#125;"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>条件求值</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/login&#125;"</span> <span class="attr">th:unless</span>=<span class="string">"$&#123;session.user != null&#125;"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>for循环</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"prod : $&#123;prods&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;prod.getName()&#125;"</span>&gt;</span>Onions<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;prod.getPrice()&#125;"</span>&gt;</span>2.41<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;prod.isInStock&#125; ? #&#123;true&#125; : #&#123;false&#125;"</span>&gt;</span>yes<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>暂时就列这几个</p><h3 id="页面即原型"><a href="#页面即原型" class="headerlink" title="页面即原型"></a>页面即原型</h3><p>在Web开发过程中一个绕不开的话题就是前端工程师与后端工程师的协作，在传统Java Web开发过程中，前端工程师和后端工程师一样，也需要安装一套完整的开发环境，然后各类Java IDE中修改模板、静态资源文件，启动/重启/重新加载应用服务器，刷新页面查看最终效果。</p><p>但实际上前端工程师的职责更多应该关注于页面本身而非后端，使用JSP，Velocity等传统的Java模板引擎很难做到这一点，因为它们必须在应用服务器中渲染完成后才能在浏览器中看到结果，而Thymeleaf从根本上颠覆了这一过程，通过属性进行模板渲染不会引入任何新的浏览器不能识别的标签，例如JSP中的，不会在Tag内部写表达式。整个页面直接作为HTML文件用浏览器打开，几乎就可以看到最终的效果，这大大解放了前端工程师的生产力，它们的最终交付物就是纯的HTML/CSS/JavaScript文件。</p><h2 id="WebJars"><a href="#WebJars" class="headerlink" title="WebJars"></a>WebJars</h2><p>WebJars是一个很神奇的东西，可以让我们以jar包的形式来使用前端的各种框架和组件。</p><h3 id="什么是Webjars"><a href="#什么是Webjars" class="headerlink" title="什么是Webjars"></a>什么是Webjars</h3><p>什么是WebJars？WebJars是将客户端（浏览器）资源（JavaScript，Css等）打成jar包文件，以对资源进行统一依赖管理。WebJars的jar包部署在Maven中央仓库上。</p><h3 id="为什么使用"><a href="#为什么使用" class="headerlink" title="为什么使用"></a>为什么使用</h3><p>我们在开发Java web项目的时候会使用像Maven，Gradle等构建工具以实现对jar包版本依赖管理，以及项目的自动化管理，但是对于JavaScript，Css等前端资源包，我们只能采用拷贝到webapp下的方式，这样做就无法对这些资源进行依赖管理。那么WebJars就提供给我们这些前端资源的jar包形势，我们就可以进行依赖管理。</p><h3 id="怎样使用"><a href="#怎样使用" class="headerlink" title="怎样使用"></a>怎样使用</h3><ol><li><p><a href="https://www.webjars.org/" rel="external nofollow noopener noreferrer" target="_blank">WebJars官网</a>查找对应的组件，比如Bootstrap.js</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars.bower<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在页面引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/bootstrap/3.3.6/dist/css/bootstrap.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>就可以正常使用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/spring-springboot-1.jpg&quot; alt=&quot;spring-springboot-web&quot;&gt;&lt;/p&gt;&lt;p&gt;Spring Boot Web开发非常的简单，其中包括常用的json输出、filters、property、log等。
    
    </summary>
    
      <category term="SpringBoot" scheme="https://snaildev.github.io/categories/springboot/"/>
    
    
      <category term="SpringBoot" scheme="https://snaildev.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>springBoot实战（一）入门</title>
    <link href="https://snaildev.github.io/article/spring-springboot-helloword.html"/>
    <id>https://snaildev.github.io/article/spring-springboot-helloword.html</id>
    <published>2018-09-01T13:42:56.000Z</published>
    <updated>2018-10-03T08:13:20.110Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/spring-springboot-helloworld-1.jpg" alt="spring-springboot-helloworld"></p><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程，该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。Spring Boot 默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。它的核心设计思想是：<strong>约定优于配置</strong>，Spring Boot 所有开发细节都是依据此思想进行实现的。<a id="more"></a></p><p>Spring Boot 是一套全新的框架，它来自于 Spring 大家族，因此 Spring 所有具备的功能它都有并且更容易使用；同时还简化了基于 Spring 的应用开发，通过少量的代码就能创建一个独立的、产品级别的 Spring 应用。</p><p>下图展示出了 Spring Boot 在 Spring 生态中的位置： <img src="/images/spring-springboot-helloworld-2.png" alt="spring-springboot-helloworld"></p><p>该项目主要的目的是：</p><ul><li>上手 Spring 开发更快、更广泛；</li><li>使用默认方式实现快速开发；</li><li>提供大多数项目所需的非功能特性，诸如：嵌入式服务器、安全、心跳检查、外部配置等。</li></ul><p><strong>Spring Boot 特性</strong></p><ul><li>使用 Spring 项目引导页面可以在几秒构建一个项目；</li><li>方便对外输出各种形式的服务，如 REST API、WebSocket、Web、Streaming、Tasks；</li><li>非常简洁的安全策略集成；</li><li>支持关系数据库和非关系数据库；</li><li>支持运行期内嵌容器，如 Tomcat、Jetty；</li><li>强大的开发包，支持热启动；</li><li>自动管理依赖；</li><li>自带应用监控；</li><li>支持各种 IDE，如 IntelliJ IDEA、NetBeans。</li></ul><h2 id="为什么学习-Spring-Boot-？"><a href="#为什么学习-Spring-Boot-？" class="headerlink" title="为什么学习 Spring Boot ？"></a>为什么学习 Spring Boot ？</h2><p>Spring Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。同时它集成了大量常用的第三方库配置（如 Redis、MongoDB、JPA、RabbitMQ、Quartz 等），Spring Boot 应用中这些第三方库几乎可以零配置进行开箱即用，大部分的 Spring Boot 应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p><p>使用 Spring Boot 开发项目，有以下几方面优势：</p><ol><li>Spring Boot 使开发变得简单，提供了丰富的解决方案，快速集成各种解决方案提升开发效率。</li><li>Spring Boot 使配置变得简单，提供了丰富的 Starters，集成主流开源产品往往只需要简单的配置即可。</li><li>Spring Boot 使部署变得简单，其本身内嵌启动容器，仅仅需要一个命令即可启动项目，结合 Jenkins、Docker 自动化运维非常容易实现。</li><li>Spring Boot 使监控变得简单，自带监控组件，使用 Actuator 轻松监控服务各项状态。</li></ol><p>从软件发展的角度来讲，越简单的开发模式越流行，简单的开发模式解放出更多生产力，让开发人员可以避免将精力耗费在各种配置、语法所设置的门槛上，从而更专注于业务。这点上，Spring Boot 已尽可能地简化了应用开发的门槛。</p><p>Spring Boot 所集成的技术栈，涵盖了各大互联网公司的主流技术，跟着 Spring Boot 的路线去学习，基本可以了解国内外互联网公司的技术特点。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>说了那么多，手痒痒的很，马上来一发试试。</p><h3 id="maven-构建项目"><a href="#maven-构建项目" class="headerlink" title="maven 构建项目"></a>maven 构建项目</h3><ol><li>访问<a href="http://start.spring.io/" rel="external nofollow noopener noreferrer" target="_blank">http://start.spring.io/</a></li><li>选择构建工具Maven Project、Spring Boot版本1.5.16以及一些工程基本信息，点击“Switch to the full version.”java版本选择1.8，可参考下图所示： <img src="/images/spring-springboot-helloworld-3.png" alt="spring-springboot-helloworld"></li><li>点击Generate Project下载项目压缩包</li><li>解压后，使用Idea，Open -&gt; 选择解压后的文件夹中的pom.xml文件 -&gt; Open as Project</li></ol><h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/spring-springboot-helloworld-4.png" alt="spring-springboot-helloworld"> 如上图所示，Spring Boot的基础结构共三个文件：</p><ul><li>src/main/java 程序开发以及主程序入口</li><li>src/main/resources 配置文件</li><li>src/test/java 测试程序</li></ul><p>另外，Spring Boot建议的目录结构如下：</p><p>root package结构：com.example.myproject</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">    +- myproject</span><br><span class="line">      +- Application.java</span><br><span class="line">      |</span><br><span class="line">      +- domain</span><br><span class="line">      |  +- Customer.java</span><br><span class="line">      |  +- CustomerRepository.java</span><br><span class="line">      |</span><br><span class="line">      +- service</span><br><span class="line">      |  +- CustomerService.java</span><br><span class="line">      |</span><br><span class="line">      +- controller</span><br><span class="line">      |  +- CustomerController.java</span><br><span class="line">      |</span><br></pre></td></tr></table></figure><ol><li>Application.java 建议放到根目录瞎买，主要用于做一些框架配置</li><li>domain 目录主要用于实体（Entity）和数据访问层（Repository）</li><li>service 层主要是业务逻辑代码</li><li>controller 负责页面访问控制</li></ol><p>采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改</p><p>最后，启动Application main方法，至此一个java项目搭建好了。</p><h3 id="引入web模块"><a href="#引入web模块" class="headerlink" title="引入web模块"></a>引入web模块</h3><ol><li>在pom.xml文件中添加支持web的模块：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>pom.xml 文件中默认有两个模块：</p><ul><li>spring-boot-starter: 核心模块，包括自动配置支持、日志和YAML;</li><li>spring-boot-starter-test: 测试模块，包括JUnit、Hamcrest、Mockito;</li></ul><ol start="2"><li>编写controller内容<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>@RestController的作用就是controller里面的方法都以json格式输出，不用再写jackson配置，其本质实际上就是@Controller + @ResponseBody。</p><ol start="3"><li>启动主程序，打开浏览器访问<a href="http://localhost:8080/hello，就可以看到效果了，有木有很简单！" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/hello，就可以看到效果了，有木有很简单！</a></li></ol><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>打开scr/test/java 下的测试入口，编写简单的http请求来测试：使用mockmvc实现，并利用MockMcvResultHandlers.print()打印出执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldControllerTests</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        mvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> HelloWorldController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        mvc.perform(MockMvcRequestBuilders.get(<span class="string">"/hello"</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">                .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">                .andDo(MockMvcResultHandlers.print())</span><br><span class="line">                .andReturn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>热启动在正常开发项目中已经很常见了，虽然平时开发web项目过程中，改动项目后重启总是报错，但是Spring Boot对调试支持很好，修改之后可以实时生效，需要添加以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>使用idea还需要更改一些配置，setting修改，如下图： <img src="/images/spring-springboot-helloworld-5.png" alt="spring-springboot-helloworld"> 然后按组合键 Shift+Ctrl+Alt+/ 选择Registry… 找到 compiler.automake.allow.when.app.running 勾选即可。</p><p>热启动模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/spring-springboot-helloworld-1.jpg&quot; alt=&quot;spring-springboot-helloworld&quot;&gt;&lt;/p&gt;&lt;p&gt;Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程，该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。Spring Boot 默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。它的核心设计思想是：&lt;strong&gt;约定优于配置&lt;/strong&gt;，Spring Boot 所有开发细节都是依据此思想进行实现的。
    
    </summary>
    
      <category term="SpringBoot" scheme="https://snaildev.github.io/categories/springboot/"/>
    
    
      <category term="SpringBoot" scheme="https://snaildev.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>什么是H.265</title>
    <link href="https://snaildev.github.io/article/image-audio-what-is-H.265.html"/>
    <id>https://snaildev.github.io/article/image-audio-what-is-H.265.html</id>
    <published>2018-07-16T02:26:00.000Z</published>
    <updated>2018-10-03T01:37:49.969Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/h.265_1.jpg" alt="xh265-vid-top jpg pagespeed gp jp jw pj ws js rj rp rw ri cp md ic saoisp96-x"></p><p>最近偶然读了一篇文章<a href="https://mp.weixin.qq.com/s/z5y4NUr_lE_cY6FMSaIRUw" rel="external nofollow noopener noreferrer" target="_blank">一位女运维的自述：3年为公司节省10亿元！</a>，大意是腾讯运维如何运用图像影音压缩技术为公司和用户节省了大量流量，节约了成本并提高了用户体验。其中关键技术 <strong><em>H.265</em></strong> 吸引了我的注意，于是百谷歌度了一番，做了一个大致的了解。</p><a id="more"></a><p><a href="https://www.howtogeek.com/206662/should-you-get-an-ultra-hd-4k-tv/" rel="external nofollow noopener noreferrer" target="_blank">4K is the next big thing in TVs</a>, 和 <a href="https://www.howtogeek.com/300847/where-can-you-find-4k-video-for-your-4k-tv/" rel="external nofollow noopener noreferrer" target="_blank">4K videos are starting to pop up everywhere</a>. 但由于4K视频占用了大量的空间，很难以最佳质量进行下载和流式传输，而值得庆幸的是，一种被称为高效视频编码技术（High Efficiency Video Coding (HEVC), or H.265）正在改变这种情况。</p><p>这项新技术还需要很长一段时间才能得到大范围的应用，目前它正出现在—4K UHD Blu-rays 使用 HEVC, <a href="https://www.videolan.org/vlc/releases/3.0.0.html" rel="external nofollow noopener noreferrer" target="_blank">VLC 3.0</a>使得你PC机上的HEVC 和 4K 视频更加清晰，iPhone 设备甚至可以用HEVC技术记录视频以节约存储空间。但它是如何工作的，为什么对4K视频如此重要？</p><h2 id="1-当前标准：AVC-H-264"><a href="#1-当前标准：AVC-H-264" class="headerlink" title="1. 当前标准：AVC / H.264"></a>1. 当前标准：AVC / H.264</h2><p>当你观看蓝光光盘，YouTube视频或者来自ITunes的电影时，它与来自编辑室的原始视频不是完全相同的。为了是该电影或者视频更适合蓝光光盘——或者使其足够小以便在网上轻松下载——必须对电影压缩。 高级视频编码也被称为AVC或H.264,是广泛使用的视频压缩的最佳标准，并且有几种不同的方法可用于减小视频文件的大小。 例如，在任何给定的帧中，它可以查找大多数颜色相同的区域。在我和我儿子的这幅禁止帧中——大部分的天空都是相同的蓝色，因此压缩算法可以将图像分割成块——称之为“macroblocks”——并表明“我们仅仅假设沿着顶部的所有这些块都是相同的蓝色以替代记录每个像素的颜色”。这比存储每个单独像素的颜色效率更高，降低最终图像的文件大小。在视频中， 该技术被称之为帧内压缩——压缩单个帧的数据。</p><p><img src="/images/h.265_2.jpg" alt="img_1617-1"></p><p>AVC还使用帧间压缩，它可以查看多个帧并记录帧的哪些部分正在改变 - 哪些不是。从“美国队长：内战”中获得这一镜头。 背景并没有太大的变化 - 帧之间的差异大部分来自钢铁侠的脸部和身体。 所以，压缩算法可以将帧分成相同的宏块，并表明“你知道什么？ 这些块不会改变100帧，所以让我们再次显示它们，而不是将整个图像存储100次。“这可以显著减小文件大小。</p><p><img src="/images/h.265_3.gif" alt="5af0120085a6c_5af012009aeab"></p><p>这些只是AVC / H.264使用方法的两个过度简化的例子，但您清楚了其中的原理。 这完全是为了在不影响质量的情况下提高视频文件的效率。 （当然，如果压缩太多，任何视频都会失去质量，但这些技术越聪明，在您进入该点之前就可以压缩越多。）</p><h2 id="2-HEVC-H-265更高效地压缩视频，非常适合4K视频"><a href="#2-HEVC-H-265更高效地压缩视频，非常适合4K视频" class="headerlink" title="2. HEVC / H.265更高效地压缩视频，非常适合4K视频"></a>2. HEVC / H.265更高效地压缩视频，非常适合4K视频</h2><p>高效视频编码技术也称为HEVC或H.265，是视频编码技术演进的下一步。 它的构建使用了AVC / H.264中的许多技术，使视频压缩效率更高。</p><p>举个例子，当AVC查看多个帧变更时（例如上面的美国队长例子），这些宏块“块”可以是几个不同的形状和大小，最多可达16个像素乘16个像素。 而使用HEVC，这些块可以达到64×64的尺寸 - 远远大于16×16，这意味着该算法可以记忆更少的块，从而减小整体视频的尺寸。</p><p>您可以在<a href="https://www.youtube.com/channel/UCD80RKxQODrPv-PdM3Js8IQ" rel="external nofollow noopener noreferrer" target="_blank">HandyAndy Tech Tips</a>的这个精彩视频中看到对这项技术的更多技术性解释.</p><p>当然，HEVC还有其他一些技术正在运用，但这是最大的改进之一 - 当所有事情说到做到之后，HEVC可以在相同的质量水平下将视频压缩两倍于AVC。 对于用AVC技术编码而占用大量空间的4K视频而尤其重要。 HEVC使4K视频更容易流式传输，下载或翻录到硬盘。</p><h2 id="3-缺陷：HEVC在没有硬件加速解码的情况下很慢"><a href="#3-缺陷：HEVC在没有硬件加速解码的情况下很慢" class="headerlink" title="3. 缺陷：HEVC在没有硬件加速解码的情况下很慢"></a>3. 缺陷：HEVC在没有硬件加速解码的情况下很慢</h2><p>自2013年以来，HEVC一直是获批准的标准，那么为什么我们不能将它用于所有视频？ 相关： <a href="https://www.howtogeek.com/260784/how-to-make-vlc-use-less-battery-life-by-enabling-hardware-acceleration/" rel="external nofollow noopener noreferrer" target="_blank">如何通过启用硬件加速使VLC使用更少的电量</a> 这些压缩算法非常复杂 - 在视频播放之前，需要花费大量的数学计算才能实现解码。 计算机有两种主要的方式可以解码在这种视频：一软件解码，它会使用你的计算机的CPU来完成这个数学运算，或者二<a href="https://www.howtogeek.com/260784/how-to-make-vlc-use-less-battery-life-by-enabling-hardware-acceleration/" rel="external nofollow noopener noreferrer" target="_blank">硬件解码</a> ，在这个解码过程中，它将负载交给你的图形卡（或者你的集成图形芯片中央处理器）。 只要显卡支持所尝试播放的视频的编解码器，则效率更高。</p><p>因此，尽管许多PC和程序都可以尝试播放HEVC视频，但是如果没有硬件解码，它可能会卡顿或者非常慢。 所以，除非你有一个支持HEVC硬件解码的图形卡和视频播放器，否则HEVC对你来说并不是很好。</p><p>这对于独立播放设备来说不是问题 - 包括Xbox One在内的4K蓝光播放机都是以HEVC为基础构建的。 但是当谈到在PC上播放HEVC视频时，事情变得更加困难。 您的计算机将需要以下硬件之一才能硬解码HEVC视频：</p><ul><li>英特尔第六代“Skylake”或更新的CPU</li><li>AMD第六代“Carizzo”或更新的APU</li><li>NVIDIA GeForce GTX 950,960或更新的显卡</li><li>AMD Radeon R9 Fury，R9 Fury X，R9 Nano或更新的显卡</li></ul><p>您可能还需要使用不仅能支持HEVC视频，而且还支持HEVC硬件解码的操作系统和视频播放器 - 目前这有点多余。 许多玩家仍在增加对HEVC硬件解码的支持，并且在某些情况下，它可能仅适用于上面列表中的某些芯片。 在撰写本文时， <a href="https://www.videolan.org/" rel="external nofollow noopener noreferrer" target="_blank">VLC</a> 3.0， <a href="https://kodi.tv/" rel="external nofollow noopener noreferrer" target="_blank">Kodi</a> 17和<a href="https://www.plex.tv/" rel="external nofollow noopener noreferrer" target="_blank">Plex Media Server</a> 1.10都支持某种形式的HEVC硬件解码，至少对于某些卡而言。 不过，您可能必须在选择的播放器中<a href="https://www.howtogeek.com/260784/how-to-make-vlc-use-less-battery-life-by-enabling-hardware-acceleration/" rel="external nofollow noopener noreferrer" target="_blank">启用硬件加速</a>才能正常工作。</p><p>随着时间的推移，越来越多的计算机将能够处理这种视频，而更多的播放器将会更广泛地支持它 - 就像现在使用AVC / H.264一样。 它可能需要一段时间才会变得无处不在，在此之前，您必须以巨大的文件大小（或压缩它并丢失图像质量）将您的4K视频存储在AVC / H.264中。 但是，HEVC / H.265得到广泛支持越多，视频就越好。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p>图片来源： <a href="https://www.shutterstock.com/image-photo/realism-sporting-images-broadcast-on-tv-725299213" rel="external nofollow noopener noreferrer" target="_blank">alphaspirit</a> /Shutterstock.com</p><p>本文翻译自：<a href="https://www.howtogeek.com/342416/what-is-hevc-h.265-video-and-why-is-it-so-important-for-4k-movies/" rel="external nofollow noopener noreferrer" target="_blank">What Is HEVC H.265 Video, and Why Is It So Important for 4K Movies?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/h.265_1.jpg&quot; alt=&quot;xh265-vid-top jpg pagespeed gp jp jw pj ws js rj rp rw ri cp md ic saoisp96-x&quot;&gt;&lt;/p&gt;&lt;p&gt;最近偶然读了一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/z5y4NUr_lE_cY6FMSaIRUw&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;一位女运维的自述：3年为公司节省10亿元！&lt;/a&gt;，大意是腾讯运维如何运用图像影音压缩技术为公司和用户节省了大量流量，节约了成本并提高了用户体验。其中关键技术 &lt;strong&gt;&lt;em&gt;H.265&lt;/em&gt;&lt;/strong&gt; 吸引了我的注意，于是百谷歌度了一番，做了一个大致的了解。&lt;/p&gt;
    
    </summary>
    
      <category term="图像影音" scheme="https://snaildev.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BD%B1%E9%9F%B3/"/>
    
    
      <category term="随手写写" scheme="https://snaildev.github.io/tags/%E9%9A%8F%E6%89%8B%E5%86%99%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>java基础（二）封装</title>
    <link href="https://snaildev.github.io/article/java-base-object-oriented-encapsulation.html"/>
    <id>https://snaildev.github.io/article/java-base-object-oriented-encapsulation.html</id>
    <published>2018-06-02T13:42:56.000Z</published>
    <updated>2018-10-03T05:12:05.467Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/encapsulation_2.png" alt="encapsulation"></p><p>对于面向对象的特点，想必大家应该都可以倒背如流：封装，继承，多态。但很多人对这些特点的理解仅仅停留在表面，认为封装就是变量的私有化，然后对外开放接口，获取和设置值，而不知道为什么要这样做。</p><p>封装，简单来说就是将变量私有化，在java里的用的就是private修饰符修饰，这样在外部产生的对象就不能直接访问这个变量。想要外部对象对变量进行访问或操作，就需要在类里面提供外部访问的接口，也就是我们熟知的get和set方法。</p><p>以上就是大部分人对于封装的理解。知道有封装这回事，知道怎么用，却不知道为什么要用，甚至觉得多此一举。因为明明person.name就是访问到变量，为什么非要person.getName()呢？<a id="more"></a></p><h1 id="1-任性的使用public"><a href="#1-任性的使用public" class="headerlink" title="1. 任性的使用public"></a>1. 任性的使用public</h1><p>让我们先来看一下不使用封装的情况：</p><p>设计了3个类，人、男人、女人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String name;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> money;</span><br><span class="line">  <span class="keyword">public</span> Woman wife;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略get和set方法</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Woman woman)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wife = woman;</span><br><span class="line">    woman.marry(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Man husband;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略get和set方法</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Man man)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.husband = man;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Man man = <span class="keyword">new</span> Man();</span><br><span class="line">    man.name = <span class="string">"snail"</span>;</span><br><span class="line">    man.age = <span class="number">30</span>;</span><br><span class="line">    man.money = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    Woman woman = <span class="keyword">new</span> Woman();</span><br><span class="line">    woman.name = <span class="string">"lucy"</span>;</span><br><span class="line">    </span><br><span class="line">    man.marry(woman);</span><br><span class="line"></span><br><span class="line">    System.out.println(man.name + <span class="string">"的妻子"</span> + man.wife.name); <span class="comment">//snail的妻子：lucy</span></span><br><span class="line">    System.out.println(man.name + <span class="string">"的钱："</span> + man.money); <span class="comment">//snail的钱：10000.0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里一切正常，看起来也还不错。</p><p>但是这这个时候来了一个小偷，这个小偷呢，除了偷别人的钱和老婆啥都不干。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> <span class="keyword">extends</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> stealMoney = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Woman&gt; women = <span class="keyword">new</span> ArrayList&lt;Woman&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//偷钱</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stealMoney</span><span class="params">(Man man)</span></span>&#123;</span><br><span class="line">    stealMoney += man.money;</span><br><span class="line">    man.money = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"哈哈，偷到钱了..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//偷老婆</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stealWife</span><span class="params">(Man man)</span></span>&#123;</span><br><span class="line">    man.wife.husband = <span class="keyword">this</span>;</span><br><span class="line">    women.add(man.wife);</span><br><span class="line">    </span><br><span class="line">    Woman woman = <span class="keyword">new</span> Woman();</span><br><span class="line">    woman.name = <span class="string">"凤姐"</span>;</span><br><span class="line">    man.wife = woman;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"哈哈哈，又偷了一个妹子做老婆..."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Man man = <span class="keyword">new</span> Man();</span><br><span class="line">    man.name = <span class="string">"snail"</span>;</span><br><span class="line">    man.age = <span class="number">30</span>;</span><br><span class="line">    man.money = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    Woman woman = <span class="keyword">new</span> Woman();</span><br><span class="line">    woman.name = <span class="string">"lucy"</span>;</span><br><span class="line">    </span><br><span class="line">    man.marry(woman);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来了一个小偷</span></span><br><span class="line">    Thief thief = <span class="keyword">new</span> Thief();</span><br><span class="line">    thief.stealMoney(man);</span><br><span class="line">    thief.stealWife(man);</span><br><span class="line"></span><br><span class="line">    System.out.println(man.name + <span class="string">"的妻子"</span> + man.wife.name); <span class="comment">//snail的妻子：凤姐</span></span><br><span class="line">    System.out.println(man.name + <span class="string">"的钱："</span> + man.money); <span class="comment">//snail的钱：0.0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在傻眼了，钱和老婆都成别人的了，自己还莫名其妙的和凤姐结了婚…</p><p>这时，你觉得是时候改变一下了！！！</p><h1 id="2-封装来报到"><a href="#2-封装来报到" class="headerlink" title="2. 封装来报到"></a>2. 封装来报到</h1><p>封装觉得你有点惨，于是过来帮助你一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackagePerson</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageMan</span> <span class="keyword">extends</span> <span class="title">PackagePerson</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> PackageWoman wife;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PackageMan</span><span class="params">(String name, <span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setName(name);</span><br><span class="line">    <span class="keyword">this</span>.money = money;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(PackageWoman woman)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wife = woman;</span><br><span class="line">    woman.marry(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PackageWoman <span class="title">getWife</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wife;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> money;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageWoman</span> <span class="keyword">extends</span> <span class="title">PackagePerson</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> PackageMan husband;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PackageWoman</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setName(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(PackageMan man)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.husband = husband;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PackageMan <span class="title">getHusband</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> husband;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPackage</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    PackageMan man = <span class="keyword">new</span> PackageMan(<span class="string">"snail"</span>, <span class="number">10000</span>);</span><br><span class="line">    PackageWoman woman = <span class="keyword">new</span> PackageWoman(<span class="string">"lucy"</span>);</span><br><span class="line">    </span><br><span class="line">    man.marry(woman);</span><br><span class="line"></span><br><span class="line">    System.out.println(man.getName() + <span class="string">"的妻子"</span> + man.getWife().getName()); <span class="comment">//snail的妻子：lucy</span></span><br><span class="line">    System.out.println(man.getName() + <span class="string">"的钱："</span> + man.getMoney()); <span class="comment">//snail的钱：10000.0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的代码看起来除了长了点，没什么其他问题。这时候小偷已经不能偷我们的钱和老婆了，钱和老婆都被保护了起来，以至于我们自己想设置和更换都不行了，这明显不太科学…</p><h1 id="3-封装厉害的地方"><a href="#3-封装厉害的地方" class="headerlink" title="3. 封装厉害的地方"></a>3. 封装厉害的地方</h1><p>如何解决上面的问题呢？私有化外部访问不到，自己也没法改数据，提供了set方法又会让所有人都能改，和不私有设计没什么区别，好纠结。</p><p>Wait，这里说的“所有人”真的是所有人吗？</p><p>让我们来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(PackageMan man, <span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(man == <span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.money = money;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"喂，110吗？"</span> + man.getName() + <span class="string">" 抢钱！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPackage</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    PackageMan man = <span class="keyword">new</span> PackageMan(<span class="string">"snail"</span>, <span class="number">10000</span>);</span><br><span class="line">    PackageMan man1 = <span class="keyword">new</span> PackageMan(<span class="string">"thief"</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    man.setMoney(man, <span class="number">20000</span>);</span><br><span class="line">    System.out.println(man.getName() + <span class="string">"的钱："</span> + man.getMoney()); <span class="comment">//snail的钱：20000.0</span></span><br><span class="line"></span><br><span class="line">    man.setMoney(man1, <span class="number">0</span>); <span class="comment">//喂，110吗？thief 抢钱！</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样就只有自己可以修改了，别人不可以。</p><p>但是你老婆不满意了，凭什么只有你自己可以改？我也想改！</p><p>这种需求还是应该满足一下的，怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Object obj, <span class="keyword">double</span> money)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(obj == <span class="keyword">this</span> || obj == <span class="keyword">this</span>.wife)&#123;</span><br><span class="line">    <span class="keyword">this</span>.money = money;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"喂，110吗？有人抢钱！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="4-总结一下"><a href="#4-总结一下" class="headerlink" title="4. 总结一下"></a>4. 总结一下</h1><p>以上就是对面向对象中的封装的理解，封装不仅仅只是 private + getter and setter。使用封装可以对setter进行更深层次的定制，我们可以对可以执行的setter方法的对象做规定，也可以对数据操作要求，还可以做类型转换等一系列可以想到的。</p><p>使用封装不仅仅是安全，更可以简化操作。不要觉得用了封装多了好多代码，看起来乱糟糟的。如果你写一个大系统，一开始你可能这样定义属性的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure><p></p><p>你的程序里大概有100处这样的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.age = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p></p><p>这个时候，突然有需求要求把数据类型变了，改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String age;</span><br></pre></td></tr></table></figure><p></p><p>那么重构代码是不是要把那100处数据都加个双引号呢？是不是特别麻烦？</p><p>但是如果用了封装，只需要这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = String.valueOf(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>是不是简化了操作？</p><p>这里只是举个栗子，实际开发中也不会出现改变数据类型这么操蛋的事…</p><p>封装还有一个好处就是模块化。当你参与一个很多人实现的大型系统中，不可能知道所有的类是怎样实现的。只需要知道这个类提供了哪些方法，需要传入什么数据，能得到什么样的结果。至于怎么得到的，关我X事？</p><p>所以说，如果你写的代码还没用封装，改过来吧。不仅仅因为大家都在用，而是这确实可以给我们提供很大的便利。 封装的有以下四大好处：</p><ol><li>良好的封装能够减少耦合</li><li>类内部的结构可以自由修改</li><li>可以对成员进行更精确的控制</li><li>隐藏信息和实现细节</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/encapsulation_2.png&quot; alt=&quot;encapsulation&quot;&gt;&lt;/p&gt;&lt;p&gt;对于面向对象的特点，想必大家应该都可以倒背如流：封装，继承，多态。但很多人对这些特点的理解仅仅停留在表面，认为封装就是变量的私有化，然后对外开放接口，获取和设置值，而不知道为什么要这样做。&lt;/p&gt;&lt;p&gt;封装，简单来说就是将变量私有化，在java里的用的就是private修饰符修饰，这样在外部产生的对象就不能直接访问这个变量。想要外部对象对变量进行访问或操作，就需要在类里面提供外部访问的接口，也就是我们熟知的get和set方法。&lt;/p&gt;&lt;p&gt;以上就是大部分人对于封装的理解。知道有封装这回事，知道怎么用，却不知道为什么要用，甚至觉得多此一举。因为明明person.name就是访问到变量，为什么非要person.getName()呢？
    
    </summary>
    
      <category term="Java基础" scheme="https://snaildev.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://snaildev.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>java基础（一）面向对象</title>
    <link href="https://snaildev.github.io/article/java-base-object-oriented.html"/>
    <id>https://snaildev.github.io/article/java-base-object-oriented.html</id>
    <published>2018-06-01T14:13:32.000Z</published>
    <updated>2018-10-03T01:36:07.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/object-oriented-programming_1.jpg" alt="object-oriented-programming"></p><p>面向对象的思想面向过程的思想有着本质的区别的，对于面向过程的思维来说，我们分析解决问题时会将问题拆分成n个步骤，第一步先做什么，第二步再做什么；而对于面向对象的思维来说，<strong>会首先分析问题里面涉及到哪些类和对象，然后再分析这些类和对象应该具有哪些属性和方法，最后分析类与类之间的关系</strong>。</p><p>面向对象有一个非常重要的设计思维：合适的方法应该出现在合适的类里面。<a id="more"></a></p><h1 id="1-简单理解面向对象的思想"><a href="#1-简单理解面向对象的思想" class="headerlink" title="1. 简单理解面向对象的思想"></a>1. 简单理解面向对象的思想</h1><p>面对问题域：</p><p>不能</p><ul><li><del>考虑解决方案实现，第一步应该干什么，第二步应该干什么…</del></li></ul><p>应该</p><ul><li>先分析问题解决方案 涉及到的类和对象</li><li>然后分析各个类和对象对应的动静态属性</li><li>最后分析抽象对象和对象之间的关系</li></ul><h1 id="2-面向对象的设计思想"><a href="#2-面向对象的设计思想" class="headerlink" title="2. 面向对象的设计思想"></a>2. 面向对象的设计思想</h1><p>面向对象的基本思想是，从现实世界中可观存在的事物出发来构造软件系统，并在系统的构造中尽可能运用人类的自然思维方式。</p><p>面向对象更加强调运用人类在日常生活的逻辑思维中经常采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。</p><p>人在思考的时候，首先眼睛里看到的是一个个对象。</p><h2 id="2-1-对象和类的概念"><a href="#2-1-对象和类的概念" class="headerlink" title="2.1 对象和类的概念"></a>2.1 对象和类的概念</h2><p>对象是用于计算机语言对问题域中事物的描述，对象通过“属性(attribute)”和“方法(method)”来分别对应事物所具有的静态属性和动态属性。</p><p>类是用于描述同一类对象的一个抽象的概念，类中定义了这一类对象所具有的静态属性和动态属性。</p><p>类可以看成一类对象的模板，对象可以看成该类的一个具体的实例。</p><p>举个栗子：</p><p>人的定义：能制造工具并能熟练使用工具进行劳动的高等动物。</p><p>给人下定义的过程，其实就是把人的相关特性抽象出来，如：</p><ol><li>能制造工具；</li><li>能熟练使用工具；</li><li>高等动物。</li></ol><p>人在这里叫做这一类事物的抽象，在你的脑子里有人的概念，可人的概念在脑子里到底是怎样的？ 首先人是高等动物，那么高等动物这个特征就是人的静态属性，其次，这个高等动物可以 制造工具并熟练使用工具，制造工具和熟练使用工具就是人的动态属性。反应到java的类上，就是一个是成员变量（静态属性），一个是方法（动态属性）。脑子里的人的概念其实是一类事物的抽象，这种抽象的东西我们就叫做类，椅子是类，桌子是类，交通工具也是类，而这一类事物的具体实例就是对象了。</p><h2 id="2-2-如何抽象出一个类"><a href="#2-2-如何抽象出一个类" class="headerlink" title="2.2 如何抽象出一个类"></a>2.2 如何抽象出一个类</h2><p>上文已经说明面向对象的设计思想就是对问题域特征进行抽象，抽象出一些类，那么该如何去做呢？首先需要明确的是，<strong>类具有静态属性和动态属性</strong>，那么反应到java类中的体现就是，<strong>成员变量和方法</strong>。</p><p>让我们来看一下职员的抽象：</p><p><img src="/images/object-oriented-programming_2.jpg" alt="object-oriented-programming"></p><p>首先分析下，职员有哪些属性？有姓名，年龄，目前薪资等属性；有哪些方法？显示姓名，显示年龄，修改姓名，领取工资。当然，所有的方法其实都可以让别人来做，但<strong>面向对象的设计思想就是方法应该出现在最合适的类里面</strong>，这里显然职员这个类自己最合适。</p><p>对于每个对象来说，它都有一些属性（成员变量），只不过对象间的取值不同而已。上图所描述的职员这个类实例化出两个职员，职员A和职员B，他们都有姓名、年龄和目前薪资这些属性，但具体数值却不一样，正因为这些变化，对象和对象之间才能区分开来。</p><p>如何区分类和对象？类是一类具有共同特征事物的抽象，而对象就是这个类下面的具体实例了。</p><h2 id="2-3-类（对象）之间的关系"><a href="#2-3-类（对象）之间的关系" class="headerlink" title="2.3 类（对象）之间的关系"></a>2.3 类（对象）之间的关系</h2><h3 id="2-3-1-关联关系"><a href="#2-3-1-关联关系" class="headerlink" title="2.3.1 关联关系"></a>2.3.1 关联关系</h3><p><img src="/images/object-oriented-programming_3.jpg" alt="object-oriented-programming"></p><p>类和类之间存在关系的，如学生和老师这两个类，老师可以教学生，学生可以向老师学习，这是他们之间的关系，而关系和关系之间也是不同，你和你老婆的关系和你和你其他女朋友的关系是不能混为一谈的。关系中<strong>最弱</strong>的一种关系就是关联关系了。关联关系反应到程序上往往是一个类的方法里面的参数是另一个类的具体对象，比如教授教学生，教哪个学生，教学是教授这个类的一个方法，某个研究生是研究生这个类里面的一个具体对象，这两个类或者说对象之间有关系，但是不是很紧密的关系。</p><h3 id="2-3-2-继承关系"><a href="#2-3-2-继承关系" class="headerlink" title="2.3.2 继承关系"></a>2.3.2 继承关系</h3><p><img src="/images/object-oriented-programming_4.jpg" alt="object-oriented-programming"></p><p>对应：一般和特殊</p><p>继承关系的前提：XX是一种XX。满足继承的前提就可以称之为继承关系，如游泳运动员是一种运动员，这点是满足的，那么游泳运动员就是从运动员继承过来的，游泳运动员和运动员之间就是一种继承关系。学生是一个人，学生从人继承，老师也是一个人，老师也从人继承，学生是一种老师，这点说不过去，所以学生和老师之间就不存在继承关系，因此做设计的时候分清继承关系很简单，那就是使得“XX是一种XX”说的过去。图中，运动员派生出了不同种类的运动员，包括游泳的，球类的，射击的。球类运动员再派生出足球的，篮球的，排球的，这就是一棵继承树，不过这棵树是比较理想的情况，只有一个根节点。但是实际中，继承关系不一定只从一个类继承，可能从多个类继承，比如说，孩子即继承父亲这个类，也继承母亲这个类。C++正是想封装这种关系，所以它存在多继承。</p><h3 id="2-3-3-聚合关系"><a href="#2-3-3-聚合关系" class="headerlink" title="2.3.3 聚合关系"></a>2.3.3 聚合关系</h3><p><img src="/images/object-oriented-programming_5.jpg" alt="object-oriented-programming"></p><p>对应：整体和部分</p><p>什么是聚合？聚合就是一个整体和部分的关系。我们是“XX是XX的一部分”，只要说的通，他就是聚合关系，队长是球队的一部分，队员也是球队的一部分，因此队长和球队，队员和球队都是聚合关系。脑袋是人的一部分，身体和胳膊也是人的一部分，因此脑袋、身体和胳膊与人都是聚合关系。聚合关系再分细一点就是<strong>聚集关系和组合关系</strong>，比如球队、队长、队员，这三者是聚集关系，假如这个队长既是足球队的队长，也是篮球队的队长，一个人分属两个不同的球队，这是可以的，球队和队长之间没有不可分割的关系，这就是<strong>聚集关系</strong>。而另一种<strong>组合关系</strong>，就是一种不可分割的关系，相对于一个人的脑袋不可能既属于你又属于别人，身体也一样不可能同时属于多个人。</p><h3 id="2-3-4-实现关系"><a href="#2-3-4-实现关系" class="headerlink" title="2.3.4 实现关系"></a>2.3.4 实现关系</h3><p><img src="/images/object-oriented-programming_6.jpg" alt="object-oriented-programming"></p><p>对于父类（抽象类）或接口来说，我觉得应该具有这样一个方法，但是不知道具体怎么实现，谁去实现，我的子类实现，这就是实现关系。而根据实现不同，具有不同的表现形态，这就是多态。</p><h3 id="2-3-5-多态"><a href="#2-3-5-多态" class="headerlink" title="2.3.5 多态"></a>2.3.5 多态</h3><p><img src="/images/object-oriented-programming_7.jpg" alt="object-oriented-programming"></p><h1 id="3-Java与面向对象"><a href="#3-Java与面向对象" class="headerlink" title="3. Java与面向对象"></a>3. Java与面向对象</h1><ul><li>对象是Java程序的核心，在Java程序中“万物皆对象”；</li><li>对象可以看成是静态属性（成员变量）和动态属性（方法）的封装体；</li><li>类是创建同一类型对象的“模板”，在类中定义了一个对象所应具有的成员变量和方法；</li><li>J2SDK提供了很多类供编程人员使用，编程人员也可以定义自己的类。</li></ul><p>对象和类是分不开的，必须首先定义类才能有对象，首先定义方法才能调用。对象是Java里面的核心，做任何东西你首先造出一个对象才能做。静态属性简称属性，也叫成员变量，以后说属性或者说成员变量他们指的都是同一回事。</p><p>整个类可以看作是静态的属性还有方法之间的一个综合。怎么抽象出一个类的概念，从两方面入手，一个是静态属性，即具有哪些成员变量，另一个就是动态属性，具有哪些方法。</p><p>下面是一段示例代码，可以仔细体会下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter和setter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeTools</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在制造工具"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useTools</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我在使用工具"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="4-为什么使用面向对象编程？"><a href="#4-为什么使用面向对象编程？" class="headerlink" title="4. 为什么使用面向对象编程？"></a>4. 为什么使用面向对象编程？</h1><p>面向对象编程就是使用一组对象互相配合通过沟通一起完成特定的功能.做软件苦苦追求的一种境界是可重用性（reusable）,可扩展性。如果是面向过程，一般情况下属性和方法是分开的，没有关系的，这样复用起来很麻烦，而且局限在方法这个层次上，而面向对象则不同，它将属性和方法包装，可以综合起来复用，就是整个对象的复用。所以面向对象和面向过程相比，前者明显更容易让我们达到可重用性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/object-oriented-programming_1.jpg&quot; alt=&quot;object-oriented-programming&quot;&gt;&lt;/p&gt;&lt;p&gt;面向对象的思想面向过程的思想有着本质的区别的，对于面向过程的思维来说，我们分析解决问题时会将问题拆分成n个步骤，第一步先做什么，第二步再做什么；而对于面向对象的思维来说，&lt;strong&gt;会首先分析问题里面涉及到哪些类和对象，然后再分析这些类和对象应该具有哪些属性和方法，最后分析类与类之间的关系&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;面向对象有一个非常重要的设计思维：合适的方法应该出现在合适的类里面。
    
    </summary>
    
      <category term="Java基础" scheme="https://snaildev.github.io/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://snaildev.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Consul服务治理</title>
    <link href="https://snaildev.github.io/article/microservice-consul.html"/>
    <id>https://snaildev.github.io/article/microservice-consul.html</id>
    <published>2018-05-09T09:53:00.000Z</published>
    <updated>2018-10-03T01:37:18.697Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/consul.jpg" alt="consul"></p><p>Consul是google开源的一个使用go语言开发的服务发现、配置管理中心服务。内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（如ZooKeeper等）。服务部署简单，只有一个可运行的二进制的包。每个节点都需要运行agent，他有两种运行模式server和client。每个数据中心官方建议需要3或5个server节点以保证数据安全，同时保证server-leader的选举能够正确的进行。<a id="more"></a></p><ul><li><p>client</p><p>client表示Consul的client模式，就是客户端模式。是Consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到server，本身是不持久化这些信息。</p></li><li><p>server</p><p>server表示Consul的server模式，表明这个Consul是个server，这种模式下，功能和client都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。</p></li><li><p>server-leader</p><p>中间那个server下面有leader的字眼，表明这个server是它们的老大，它和其它server不一样的一点是，它需要负责同步注册的信息给其它的server，同时也要负责各个节点的健康监测。</p></li><li><p>raft</p><p>server节点之间的数据一致性保证，一致性协议使用的是raft，而zookeeper用的paxos，etcd采用的也是taft。</p></li><li><p>服务发现协议</p><p>Consul采用http和dns协议，etcd只支持http</p></li><li><p>服务注册</p><p>Consul支持两种方式实现服务注册，一种是通过Consul的服务注册http API，由服务自己调用API实现注册，另一种方式是通过json个是的配置文件实现注册，将需要注册的服务以json格式的配置文件给出。Consul官方建议使用第二种方式。</p></li><li><p>服务发现</p><p>Consul支持两种方式实现服务发现，一种是通过http API来查询有哪些服务，另外一种是通过Consul agent 自带的DNS（8600端口），域名是以NAME.service.consul的形式给出，NAME即在定义的服务配置文件中，服务的名称。DNS方式可以通过check的方式检查服务。</p></li><li><p>服务间的通信协议</p><p>Consul使用gossip协议管理成员关系、广播消息到整个集群，他有两个gossip pool（LAN pool和WAN pool），LAN pool是同一个数据中心内部通信的，WAN pool是多个数据中心通信的，LAN pool有多个，WAN pool只有一个。</p></li></ul><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>首先去官网现在合适的consul包：<a href="https://www.consul.io/downloads.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.consul.io/downloads.html</a> 安装直接下载zip包，解压后只有一个可执行的文件consul，将consul添加到系统的环境变量里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#unzip consul_1.0.2_linux_amd64.zip</span></span><br><span class="line"><span class="comment">#cp -a consul  /usr/bin</span></span><br><span class="line"><span class="comment">#consul</span></span><br></pre></td></tr></table></figure><p></p><p><img src="/images/consul_1.png" alt="1200972-20180104111330034-1408661682"></p><p>出现上面的内容证明安装成功。</p><h2 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h2><p>consul必须启动agent才能使用，有两种启动模式server和client，还有一个官方自带的ui。server用与持久化服务信息，集群官方建议3或5个节点。client只用与于server交互。ui可以查看集群情况的。</p><p><strong>Server</strong></p><p>cn1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent -bootstrap-expect 2 -server -data-dir /data/consul0 -node=cn1 -bind=192.168.1.202 -config-dir /etc/consul.d -enable-script-checks=true -datacenter=dc1</span></span><br></pre></td></tr></table></figure><p></p><p>cn2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent -server  -data-dir /data/consul0 -node=cn2 -bind=192.168.1.201 -config-dir /etc/consul.d -enable-script-checks=true -datacenter=dc1 -join 192.168.1.202</span></span><br></pre></td></tr></table></figure><p></p><p>cn3:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent -server -data-dir /data/consul0 -node=cn3 -bind=192.168.1.200 -config-dir /etc/consul.d -enable-script-checks=true -datacenter=dc1 -join 192.168.1.202</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>参数解释：</p><ul><li>-bootstrap-expect： 集群期望的节点数，只有节点数量达到这个值才会选举leader。</li><li>-server： 运行在server模式</li><li>-data-dir：指定数据目录，其他的节点对于这个目录必须有读的权限</li><li>-node：指定节点的名称</li><li>-bind：为该节点绑定一个地址</li><li>-config-dir：指定配置文件，定义服务的，默认所有一.json结尾的文件都会读</li><li>-enable-script-checks=true：设置检查服务为可用</li><li>-datacenter： 数据中心没名称，</li><li>-join：加入到已有的集群中</li></ul></blockquote><p><strong>Client</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent   -data-dir /data/consul0 -node=cn4 -bind=192.168.1.199 -config-dir /etc/consul.d -enable-script-checks=true  -datacenter=dc1  -join 192.168.1.202</span></span><br></pre></td></tr></table></figure><p></p><p>client节点可以有多个，自己根据服务指定即可。</p><p><strong>UI</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent  -ui  -data-dir /data/consul0 -node=cn4 -bind=192.168.1.198  -client 192.168.1.198   -config-dir /etc/consul.d -enable-script-checks=true  -datacenter=dc1  -join 192.168.1.202</span></span><br></pre></td></tr></table></figure><p></p><blockquote><ul><li>-ui：使用自带的ui，</li><li>-ui-dir：指定ui的目录，使用自己定义的ui</li><li>-client：指定web ui、的监听地址，默认127.0.0.1只能本机访问。</li></ul></blockquote><p>集群创建完成后，可以使用一些常用的命令检查集群的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul  info</span></span><br></pre></td></tr></table></figure><p></p><p>可以在raft：stat看到此节点的状态是fllower或者leader</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul members</span></span><br><span class="line"></span><br><span class="line">Node Address Status Type Build Protocol DC Segment</span><br><span class="line">cn1 192.168.1.202:8301 alive server 1.0.2 2 dc1 &lt;all&gt;</span><br><span class="line">cn2 192.168.1.201:8301 alive server 1.0.2 2 dc1 &lt;all&gt;</span><br><span class="line">cn3 192.168.1.200:8301 alive client 1.0.2 2 dc1 &lt;default&gt;</span><br></pre></td></tr></table></figure><p></p><p>新加入一个节点有几种方式:</p><ol><li><p>这种方式，重启后不会自动加入集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul  join  192.168.1.202</span></span><br></pre></td></tr></table></figure></li><li><p>在启动的时候使用-join指定一个集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent  -ui  -data-dir /data/consul0 -node=cn4 -bind=192.168.1.198 -config-dir /etc/consul.d -enable-script-checks=true  -datacenter=dc1  -join 192.168.1.202</span></span><br></pre></td></tr></table></figure></li><li><p>使用-startjoin或-rejoin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent  -ui  -data-dir /data/consul0 -node=cn4 -bind=192.168.1.198 -config-dir /etc/consul.d -enable-script-checks=true  -datacenter=dc1  -rejoin</span></span><br></pre></td></tr></table></figure></li></ol><p>访问ui: <a href="http://192.168.1.198:8500/ui" rel="external nofollow noopener noreferrer" target="_blank">http://192.168.1.198:8500/ui</a></p><blockquote><p>端口： 8300：consul agent服务relplaction、rpc（client-server） 8301：lan gossip 8302：wan gossip 8500：http api端口 8600：DNS服务端口</p></blockquote><h2 id="3-服务注册"><a href="#3-服务注册" class="headerlink" title="3. 服务注册"></a>3. 服务注册</h2><p>采用的是配置文件的方式，（官方推荐）首先创建一个目录用于存放定义服务的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mkdir /etc/consul.d/</span></span><br></pre></td></tr></table></figure><p></p><p>启动服务的时候要使用-config-dir 参数指定。</p><p>下面给出一个服务定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat web.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"service"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"web"</span>,</span><br><span class="line">    <span class="string">"tags"</span>: [<span class="string">"rails"</span>],</span><br><span class="line">    <span class="string">"port"</span>: 80,</span><br><span class="line">    <span class="string">"check"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"ping"</span>,</span><br><span class="line">      <span class="string">"script"</span>: <span class="string">"curl -s localhost:80"</span>,</span><br><span class="line">      <span class="string">"interval"</span>: <span class="string">"3s"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动后就可以在没有运行web服务的机器上面执行DNS查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dig @127.0.0.1 -p 8600 web.service.consul SRV</span></span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">web.service.consul.0INSRV1 1 80 cn2.node.dc1.consul.</span><br><span class="line">web.service.consul.0INSRV1 1 80 cn3.node.dc1.consul.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">cn2.node.dc1.consul.0INA192.168.1.201</span><br><span class="line">cn2.node.dc1.consul.0INTXT<span class="string">"consul-network-segment="</span></span><br><span class="line">cn3.node.dc1.consul.0INA192.168.1.200</span><br><span class="line">cn3.node.dc1.consul.0INTXT<span class="string">"consul-network-segment="</span></span><br><span class="line"></span><br><span class="line">;; Query time: 17 msec</span><br><span class="line">;; SERVER: 127.0.0.1<span class="comment">#8600(127.0.0.1)</span></span><br><span class="line">;; WHEN: 四 1月 04 14:39:32 CST 2018</span><br><span class="line">;; MSG SIZE rcvd: 229</span><br></pre></td></tr></table></figure><p></p><p>可以看到服务已经注册到集群里面了。 使用dns查询，默认域名格式NAME.service.consul，NAME就是web.json里面定义的service的name。可以自己指定域和端口：-domain、-dns-port 53</p><h2 id="4-健康检查"><a href="#4-健康检查" class="headerlink" title="4. 健康检查"></a>4. 健康检查</h2><p>check使用来做服务的健康检查的，可以拥有多个，也可以不使用支持多种方式检查。check必须是script或者TTL类型的，如果是script类型则script和interval变量必须被提供，如果是TTL类型则ttl变量必须被提供。script是consul主动去检查服务的健康状况，ttl是服务主动向consul报告自己的状况。</p><ul><li><p>script check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"check"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: mutil - memory,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"memory utilization"</span>,</span><br><span class="line">    <span class="string">"tags"</span>: [<span class="string">"system"</span>],</span><br><span class="line">    <span class="string">"script"</span>: <span class="string">"/etc/init.d/check_memory.py"</span>,</span><br><span class="line">    <span class="string">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>http check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"check"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"api"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"HTTP API  500"</span>,</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://loclhost:500/health"</span>,</span><br><span class="line">    <span class="string">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>tcp check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"check"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"ssh"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ssh TCP 26622"</span>,</span><br><span class="line">    <span class="string">"tcp"</span>: <span class="string">"localhost:26622"</span>,</span><br><span class="line">    <span class="string">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ttl check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"check"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"web-app"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Web APP status"</span>,</span><br><span class="line">    <span class="string">"notes"</span>: <span class="string">"Web APP does a curl  internally every 10 seconds"</span>,</span><br><span class="line">    <span class="string">"ttl"</span>: <span class="string">"30s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>全文完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/consul.jpg&quot; alt=&quot;consul&quot;&gt;&lt;/p&gt;&lt;p&gt;Consul是google开源的一个使用go语言开发的服务发现、配置管理中心服务。内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（如ZooKeeper等）。服务部署简单，只有一个可运行的二进制的包。每个节点都需要运行agent，他有两种运行模式server和client。每个数据中心官方建议需要3或5个server节点以保证数据安全，同时保证server-leader的选举能够正确的进行。
    
    </summary>
    
      <category term="服务治理" scheme="https://snaildev.github.io/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
    
      <category term="服务治理" scheme="https://snaildev.github.io/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>高性能js库Lodash</title>
    <link href="https://snaildev.github.io/article/javascript-library-lodash.html"/>
    <id>https://snaildev.github.io/article/javascript-library-lodash.html</id>
    <published>2018-05-08T03:09:00.000Z</published>
    <updated>2018-10-03T01:39:08.990Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/lodash_0.jpg" alt="timg"></p><p>有几年开发经验的工程师，往往都会有自己的一套工具库，称为utils、helpers等等，这套库一方面是自己的技术积累，另一方面也是对某项技术的扩展，领先于技术规范的制订和实现。 Lodash就是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前ECMAScript尚未制订的规范，但同时被业界所认可的辅助函数。而且每天使用npm安装Lodash的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。<a id="more"></a></p><h2 id="1-模块组成"><a href="#1-模块组成" class="headerlink" title="1. 模块组成"></a>1. 模块组成</h2><ul><li>Lodash听得辅助函数主要分为以下几类，函数列表和用法实力请查看Lodash的官方文档：</li><li>Array， 适合于数组类型，比如填充数据、查找元素、数组分片等操作</li><li>Collocation， 适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作</li><li>Function， 适用于函数类型，比如节流、延迟、缓存、设置钩子等操作</li><li>Lang， 普遍适用于各种类型，常用于执行类型判断和类型转换</li><li>Math， 使用与数值类型，常用于执行数学运算</li><li>Number， 适用于生成随机数，比较数值与数值区间的关系</li><li>Object， 适用于对象类型，常用于对象的创建、扩展、类型转换、检索、集合等操作</li><li>Seq， 常用于创建链式调用，提高执行性能（惰性计算）</li><li>String， 适用于字符串类型</li><li>lodash/fp 模块提供了更接近函数式编程的开发方法，其内部的函数经过包装，具有immutable、auto-curried、iteratee-first、data-last（官方介绍）等特点。</li><li>Fixed Arity，固化参数个数，便于柯里化</li><li>Rearragned Arguments， 重新调整参数位置，便于函数之间的聚合</li><li>Capped Iteratee Argument， 封装Iteratee参数</li></ul><h2 id="1-性能"><a href="#1-性能" class="headerlink" title="1. 性能"></a>1. 性能</h2><p>在 Filip Zawada的文章<a href="https://link.jianshu.com/?t=http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/" rel="external nofollow noopener noreferrer" target="_blank">《How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation》</a>中提到了Lodash提高执行速度的思路，主要有三点： Lazy Evaluation、Pipelining和Deferred Execution。下面两张图来自Filip的博客：</p><p><img src="/images/lodash_1.gif" alt="976007-20180123132259975-836139498"></p><p>假设有如上图所示的问题： 从若干个求中取出三个面值小于10的球。第一步是从所有的求中取出所有面值小于10的球，第二部是从上一步的结果中去三个球。</p><p><img src="/images/lodash_2.gif" alt="976007-20180123132320240-161059187"></p><p>上图是另一个解决方案，如果一个球能够通过第一步，那么就继续执行第二步，直至结束然后测试下一个球。。。当我们取到三个球之后就中断整个循环。Filip称这是Lazy Evaluation Algorithm， 就个人理解这并不全面，他后续提到的Pipelining（管道计算），再加上一个中断循环执行的算法应该更符合这里的图示。</p><p>此外，使用Lodash的链式调用时，只有现实或隐式调用 .value 方法才会对链式调用的整个操作进行取值，这种不在声明时立即求值，而在使用时进行求职的方式，是Lazy Evaluation最大的特点。</p><h2 id="3-九个实例"><a href="#3-九个实例" class="headerlink" title="3. 九个实例"></a>3. 九个实例</h2><p>收益于Lodash的普及程度，使用它可以提高很多人开发时于都代码的效率，减少彼此之间的误解（Loss of Consciousness）。在<a href="https://link.jianshu.com/?t=http://colintoh.com/blog/lodash-10-javascript-utility-functions-stop-rewriting" rel="external nofollow noopener noreferrer" target="_blank">《Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting》</a>一文中，作者列举了多个常用的Lodash函数，实例演示了使用Lodash的技巧。</p><ol><li>N次循环</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Basic for loop.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Using Array's join and split methods</span></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">Array</span>(<span class="number">5</span>)).forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.times(<span class="number">5</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>for 语句是执行虚幻的不二选择，Array.apply也可以模拟循环，但在上面代码的使用场景下，_.tiems()的解决方法更加简洁和易于理解。</p><ol start="2"><li>深层查找属性值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the name of the first pet from each owner</span></span><br><span class="line"><span class="keyword">var</span> ownerArr = [&#123;</span><br><span class="line">    <span class="string">"owner"</span>: <span class="string">"Colin"</span>,</span><br><span class="line">    <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog1"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog2"</span>&#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">"owner"</span>: <span class="string">"John"</span>,</span><br><span class="line">    <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog3"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog4"</span>&#125;]</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array's map method.</span></span><br><span class="line">ownerArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">owner</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> owner.pets[<span class="number">0</span>].name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.map(ownerArr, <span class="string">"pets[0].name"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>_.map 方法是对原生 map 方法的改进，其中使用 pets[0].name 字符串对嵌套数据取值的方式简化了很多冗余的代码，非常类似使用jQuery选择DOM节点 ul&gt;li&gt;a , 对于前端开发者来说有种久违的亲切感。</p><ol start="3"><li>个性化数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array's map method.</span></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">Array</span>(<span class="number">6</span>)).map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ball_"</span> + index; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.times(<span class="number">6</span>, _.uniqueId.bind(<span class="literal">null</span>, <span class="string">'ball_'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.times(<span class="number">6</span>, _.partial(_.uniqueId, <span class="string">'ball_'</span>));</span><br><span class="line"><span class="comment">// eg. [ball_0, ball_1, ball_2, ball_3, ball_4, ball_6]</span></span><br></pre></td></tr></table></figure></li></ol><p>在上面的代码中，我们要创建一个初始值不同、长度为6的数组，其中 _.uniqueId 方法用于生成独一无二的标示符（递增的数字，在程序运行期间保持独一无二）， _.partial 方法是对 bind 的封装。</p><ol start="4"><li>深拷贝<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"colin"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用的方法一般会比较长，循环对象等</span></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/4459928/how-to-deep-clone-in-javascript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line"><span class="keyword">var</span> objB = _.cloneDeep(objA);</span><br><span class="line">objB === objA <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ol><p>JavaScript 没有直接提供深拷贝的函数，但是我们可以用其他杉树来模拟，比如 JSON.parse(JSON.stringify(objectToClone)), 但这种方法要求对象中的属性值不能是函数。Lodash 中的 _.cloneDeep 函数封装了深拷贝的逻辑，用起来更加简洁。</p><ol start="5"><li>随机数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native utility method</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomNumber</span>(<span class="params">min, max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomNumber(<span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.random(<span class="number">15</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ol><p>Lodash 的随机数生成函数更贴近实际开发，ECMAScript 的随机数生成函数式底层必备的接口，两者都不可获取。此外，使用 _.random(15, 20, true) 还可以在15到20之间生成随机的浮点数。</p><ol start="6"><li>对象扩展<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding extend function to Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">            <span class="keyword">this</span>[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"colin"</span>, <span class="string">"car"</span>: <span class="string">"suzuki"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = &#123;<span class="string">"name"</span>: <span class="string">"james"</span>, <span class="string">"age"</span>: <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line">objA.extend(objB);</span><br><span class="line">objA; <span class="comment">// &#123;"name": "james", "age": 17, "car": "suzuki"&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.assign(objA, ojbB);</span><br></pre></td></tr></table></figure></li></ol><p>_.assign 是浅拷贝， 和ES6新增的 Object.assign 函数功能一致（建议优先使用Object.assign）。</p><ol start="7"><li>筛选属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native method: Remove an array of keys from object</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>(<span class="keyword">this</span>[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"colin"</span>, <span class="string">"car"</span>: <span class="string">"suzuki"</span>, <span class="string">"age"</span>: <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line">objA.remove([<span class="string">'car'</span>, <span class="string">'age'</span>]);</span><br><span class="line">objA; <span class="comment">// &#123;"name": "colin"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">objA = _.omit(objA, [<span class="string">'car'</span>, <span class="string">'age'</span>]);</span><br><span class="line"><span class="comment">// =&gt; &#123;"name": "colin"&#125;</span></span><br><span class="line"></span><br><span class="line">objA = _.omit(objA, <span class="string">"car"</span>);</span><br><span class="line"><span class="comment">// =&gt; &#123;"name": "colin", "age": 17&#125;</span></span><br><span class="line"></span><br><span class="line">objA = _.omit(objA, _.isNumber);</span><br><span class="line"><span class="comment">// =&gt; &#123;"name": "colin", "car": "suzuki"&#125;;</span></span><br></pre></td></tr></table></figure></li></ol><p>大多数情况下，Lodash所提供的辅助函数都会比原声的函数更贴近开发需求。在上面的代码中，开发者可以使用数组、字符串以及函数的方式筛选对象的属性，并且最终会返回一个新的对象，中间执行筛选时不会对旧对象产生影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native method: Returning a new object with selected properties</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.pick = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        obj[key] = _this[key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"colin"</span>, <span class="string">"car"</span>: <span class="string">"suzuki"</span>, <span class="string">"age"</span>: <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objB = objA.pick([<span class="string">'car'</span>, <span class="string">'age'</span>]);</span><br><span class="line"><span class="comment">// =&gt; &#123;"car": "suzuki", "age": 17&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line"><span class="keyword">var</span> objB = _.pick(objA, [<span class="string">'car'</span>, <span class="string">'age'</span>]);</span><br><span class="line"><span class="comment">// =&gt; &#123;"car": "suzuki", "age":17&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>_.pick 是 _.omit 的相反操作，用于从其他对象中挑选属性生成新的对象。</p><ol start="8"><li>随机元素<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> luckDraw = [<span class="string">"Colin"</span>, <span class="string">"John"</span>, <span class="string">"James"</span>, <span class="string">"Lily"</span>, <span class="string">"Mary"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickRandomPerson</span>(<span class="params">luckyDraw</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (luckyDraw.length - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> luckyDraw[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pickRandomPerson(luckyDraw); <span class="comment">//John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.sample(luckyDraw); <span class="comment">// Colin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash - Getting 2 random item</span></span><br><span class="line">_.sample(luckyDraw, <span class="number">2</span>); <span class="comment">// ['John', 'Lily']</span></span><br></pre></td></tr></table></figure></li></ol><p>_.sample 支持随机挑选多个元素并返回新的数组。</p><ol start="9"><li>针对 JSON.parse 的错误处理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using try-catch to handle the JSON.parse error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With Lodash</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseLodash</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.attempt(<span class="built_in">JSON</span>.parse.bind(<span class="literal">null</span>, str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parse(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line">parseLodash(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// =&gt; Return an error object</span></span><br><span class="line"></span><br><span class="line">parse(<span class="string">'&#123;"name": "colin"&#125;'</span>);</span><br><span class="line"><span class="comment">// =&gt; Return &#123;"name": "colin"&#125;</span></span><br><span class="line">parseLodash(<span class="string">'&#123;"name": "colin"&#125;'</span>);</span><br><span class="line"><span class="comment">// =&gt; Return &#123;"name": "colin"&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>如果你在使用 JSON.parse 时没有预置错误处理，那么它很有可能会成为一个定时炸弹，我们不应该默认接收的JSON对象都是有效的。 try-catch 是常见的错误处理方式，如果项目中使用Lodash，那么可以使用 _.attmpt 替代 try-catch 的方式，当解析JSON出错时，该方法会返回一个 Error 对象。</p><blockquote><p>随着ES6的普及，Lodash的功能或多或少会被原生功能所替代，所以使用时还需要进一步甄别，建议优先使用原生函数，有关ES6替代Lodash的部分，请参考文章<a href="https://link.jianshu.com/?t=http://www.zcfy.cc/article/10-lodash-features-you-can-replace-with-es6-467.html" rel="external nofollow noopener noreferrer" target="_blank">《10 个可用 ES6 替代的 Lodash 特性》</a>。</p></blockquote><p>其中有两处分别值得一看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用箭头函数创建可复用的路径</span></span><br><span class="line"><span class="keyword">const</span> object = &#123; <span class="string">'a'</span>: [&#123; <span class="string">'b'</span>: &#123; <span class="string">'c'</span>: <span class="number">3</span> &#125; &#125;, <span class="number">4</span>] &#125;;</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    obj =&gt; obj.a[<span class="number">0</span>].b.c,</span><br><span class="line">    obj =&gt; ojb.a[<span class="number">1</span>]</span><br><span class="line">].map(<span class="function"><span class="params">path</span> =&gt;</span> path(object));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数编写链式调用</span></span><br><span class="line"><span class="keyword">const</span> pipe = <span class="function"><span class="params">function</span> =&gt;</span> data =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> functions.reduce(</span><br><span class="line">        (value, func) =&gt; func(value),</span><br><span class="line">        data</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pipeline = pipe([</span><br><span class="line">    x =&gt; x * <span class="number">2</span>,</span><br><span class="line">    x =&gt; x / <span class="number">3</span>,</span><br><span class="line">    x =&gt; x &gt; <span class="number">5</span>,</span><br><span class="line">    b =&gt; !b</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">pipeline(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">pipeline(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p></p><p>在ES6中，如果一个函数只接收一个形参且函数提示一个 return 语句， 就可以使用箭头函数简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">p</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于（不完全相同）</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当有多重嵌套时，可以简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; <span class="function"><span class="params">c</span> =&gt;</span> a + b + c;</span><br><span class="line">func(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/lodash_0.jpg&quot; alt=&quot;timg&quot;&gt;&lt;/p&gt;&lt;p&gt;有几年开发经验的工程师，往往都会有自己的一套工具库，称为utils、helpers等等，这套库一方面是自己的技术积累，另一方面也是对某项技术的扩展，领先于技术规范的制订和实现。 Lodash就是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前ECMAScript尚未制订的规范，但同时被业界所认可的辅助函数。而且每天使用npm安装Lodash的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。
    
    </summary>
    
      <category term="JavaScript" scheme="https://snaildev.github.io/categories/javascript/"/>
    
    
      <category term="JavaScript" scheme="https://snaildev.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>我的简历</title>
    <link href="https://snaildev.github.io/article/about-me-my-resume.html"/>
    <id>https://snaildev.github.io/article/about-me-my-resume.html</id>
    <published>2018-03-08T13:09:00.000Z</published>
    <updated>2018-10-03T01:35:33.553Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/avatar_resume.jpg" alt="avatar"></p><a id="more"></a><p><a href="/files/java高级研发-赵明-黄山学院-猫酷科技-4年.pdf">打印入口</a></p><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul><li>手机：15821753692（微信同号）</li><li>Email：<ul><li><a href="mailto:snailtem@gmail.com" rel="external nofollow noopener noreferrer" target="_blank">snailtem@gmail.com</a> （主）</li><li><a href="mailto:snaildev@outlook.com" rel="external nofollow noopener noreferrer" target="_blank">snaildev@outlook.com</a> （备）</li></ul></li><li>QQ：1397407698</li></ul><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>赵明/男/1990</li><li>本科/黄山学院 计算机科学与技术（2010/9–2014/7）</li><li>工作年限：<strong>4年</strong></li><li>技术博客：<ul><li><a href="https://snaildev.github.io">https://snaildev.github.io</a></li><li><a href="http://www.cnblogs.com/snaildev" target="_blank" rel="noopener">http://www.cnblogs.com/snaildev</a></li></ul></li><li>Github：<a href="https://github.com/snaildev" target="_blank" rel="noopener">https://github.com/snaildev</a></li><li>期望职位：Java高级程序员，应用架构师</li><li>期望薪资：税前月薪28k+</li><li>期望城市：上海</li></ul><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h2 id="猫酷科技-（-2015年5月-至今-）"><a href="#猫酷科技-（-2015年5月-至今-）" class="headerlink" title="猫酷科技 （ 2015年5月 ~ 至今 ）"></a>猫酷科技 （ 2015年5月 ~ 至今 ）</h2><h3 id="猫酷车场"><a href="#猫酷车场" class="headerlink" title="猫酷车场"></a>猫酷车场</h3><p>实现功能：实现用户线上寻车，停车缴费等功能。</p><p>演进过程：</p><ol><li>接手：主导了猫酷车场2.0项目的研发，在1.0的基础上，对车场业务进行梳理，对上层业务代码进行封装，对底层接口对接进行开放，实现新车场接入不动上层业务代码。</li><li>改进：对接口对接层进行改进，实现配置化。第三方车场接口除了是http协议之外，也有不少是webservice/wcf这种soap协议的， 解决方式是通过抓包形式，实现报文配置的统一化。</li><li>持续改进：各个第三方接口的签名方式尽不相同，对接难免需要写代码实现，对于这种，解决方案是按照车场接口的厂商进行分类封装，重复对接同种厂商接口，仅需配置即可。</li><li>无感停车：接入支付宝车场，并开放车场相应功能（进出场通知，离场代扣）给到线下车场，使得车辆离场时不仅可以在使用会员权益、优惠券、积分后，还可以继续使用支付宝免密支付车费，无感出场。</li></ol><p>实现效果：系统更加稳定，用户体验更佳，对接成本从2人天降到0.5人天，目前车场平均月流水（多个商场合计）为800W左右</p><p>欢迎查阅：微信关注上海静安大悦城、近铁城市广场、上海环球港等可查看停车场功能。</p><p>猫酷车场简介： <img src="/images/park.jpg" alt="park"></p><h3 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h3><p>实现功能：实现代码发布、备份管理以及服务器管理等功能。</p><p>演进过程：</p><ol><li>接手分析：对发布各个流程进行分析，代码获取、代码编译、代码发布、生产环境备份、代码同步到目的服务器、 发布异常可回滚修复以及发布完成后进行接口测试等。<ul><li>代码获取（源代码管理器Git）</li><li>代码编译及发布（Java–&gt;Maven, .Net–&gt;MSBuild, .NetCore–&gt;dotnet，静态文件发布跳过编译过程）</li><li>服务器数据同步（rsync）</li><li>进行接口测试（Jmeter脚本）</li><li>发布结果推送给项目组成员（邮件通知）</li></ul></li><li>实践进行：服务器应该分环境，测试、仿真和正式。<ul><li>测试（研发发布，测试验证）</li><li>仿真（研发组长发布，研发和测试验证）</li><li>正式（就是生产环境，研发组长发布，仿真通过验证后，将仿真环境作为一个复制集同步到正式环境）</li></ul></li></ol><p>实现效果：规范了发布流程，解放了运维，使得公司约210个项目可使用发布系统稳定发布。</p><p>发布系统流程图： <img src="/images/deploy.jpg" alt="deploy"></p><h3 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h3><ul><li>长益预付卡系统对接</li><li>微信小程序发布系统</li><li>Mongo2Es实时同步工具（<a href="https://github.com/SnailDev/SnailDev.Mongo2Es）" target="_blank" rel="noopener">https://github.com/SnailDev/SnailDev.Mongo2Es）</a></li><li>MongoDB Web端查询系统（<a href="https://github.com/SnailDev/SnailDev.MongoStudio）" target="_blank" rel="noopener">https://github.com/SnailDev/SnailDev.MongoStudio）</a></li><li>票据打印机ESC/POS指令解析（<a href="https://github.com/SnailDev/SnailDev.EscPosParser）" target="_blank" rel="noopener">https://github.com/SnailDev/SnailDev.EscPosParser）</a></li><li>NestRepository查询Es SDK封装（<a href="https://github.com/SnailDev/SnailDev.Mongo2Es/blob/master/README_NESTRepo.md）" target="_blank" rel="noopener">https://github.com/SnailDev/SnailDev.Mongo2Es/blob/master/README_NESTRepo.md）</a></li></ul><h2 id="博彦科技-（-2013年10月-2015年5月-含8个月实习）"><a href="#博彦科技-（-2013年10月-2015年5月-含8个月实习）" class="headerlink" title="博彦科技 （ 2013年10月 ~ 2015年5月 含8个月实习）"></a>博彦科技 （ 2013年10月 ~ 2015年5月 含8个月实习）</h2><h3 id="美国房贷系统"><a href="#美国房贷系统" class="headerlink" title="美国房贷系统"></a>美国房贷系统</h3><p>工作内容： 参与美国房贷系统Elliemae中WebCenter功能模块的开发和维护；即组长分配JIRA,然后根据JIRA上测试或者客户反馈的bug，进行复现，阅读源代码进行审查，修复bug，提交给组长Code Review。</p><p>开发模式： 敏捷开发，晚日报，晨站会</p><h3 id="内部日报系统"><a href="#内部日报系统" class="headerlink" title="内部日报系统"></a>内部日报系统</h3><p>工作内容：基于Asp.net MVC + Entity Framework + Bootstrap内部日报和请假系统的研发。</p><p>工作说明：由于项目组采用的是敏捷开发模式，每日站会和日报都是必须的，为了满足日报和请假的需求，定制了一套适合项目组内部的日报系统和请假系统。并结合了AlertSystem实现了成员日报邮件提醒。</p><h3 id="其他项目-1"><a href="#其他项目-1" class="headerlink" title="其他项目"></a>其他项目</h3><ul><li>培训考试系统</li><li>内部小工具（HostsHelper、FileFilter、IIsHelper等）</li><li>AlertSystem（基于WindowsService后台定时Email提醒服务）</li></ul><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟练使用的技能</p><ul><li>Web开发：Java/C#.Net/Node</li><li>Web框架：Spring/Asp.Net MVC/Express</li><li>前端框架：Bootstrap/Jquery/EasyUI/LigerUI/Vue</li><li>数据库相关：MySQL/MongoDB/Redis/ElasticSearch</li><li>版本管理：Svn/Git</li><li>单元测试：JUnit</li><li>云和开放平台：SAE/阿里云/腾讯云/微信应用开发</li></ul><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/avatar_resume.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="自我认知" scheme="https://snaildev.github.io/categories/%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="随手写写" scheme="https://snaildev.github.io/tags/%E9%9A%8F%E6%89%8B%E5%86%99%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>为什么要写博客</title>
    <link href="https://snaildev.github.io/article/about-me-why-should-wirte-blog.html"/>
    <id>https://snaildev.github.io/article/about-me-why-should-wirte-blog.html</id>
    <published>2017-06-15T02:26:00.000Z</published>
    <updated>2018-10-03T01:35:47.961Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog.jpg" alt="blog"></p><blockquote><p><strong>不管你是谁，都应该现在开始经营你的个人博客。</strong></p></blockquote><a id="more"></a><h2 id="1-深度思考"><a href="#1-深度思考" class="headerlink" title="1. 深度思考"></a>1. 深度思考</h2><p>书写是为了更好的思考，看到、知道并不一定掌握，只有通过文字，有条理和逻辑的呈现出来，你才算会真正的理解和掌握，而在写作的过程，你才会把曾经松散的思路和想法串联起来，形成系统的总结。</p><h2 id="2-沉淀想法"><a href="#2-沉淀想法" class="headerlink" title="2. 沉淀想法"></a>2. 沉淀想法</h2><p>俗话说，好记性不如烂笔头，必有其道理。因为想法和创意，瞬间即逝，当你想要二次查找或者给别人介绍的时候，你会发现记忆是多么的不靠谱，而只有日常的记录和写作才可以帮你随取、随用，而且好的想法，还可以刺激和影响更多人的新想法，通过他们的评论和分享，你的想法和创意将获得倍增。</p><h2 id="3-价值杠杆"><a href="#3-价值杠杆" class="headerlink" title="3. 价值杠杆"></a>3. 价值杠杆</h2><p>一个人的价值，在于其影响力。写作是一项低门槛、高回报——即高工作杠杆率——的事情。通过写作，你可以用最简单的方式持续积累个人影响力，尤其是通过专业主题领域的持续写作，让你在特定受众群体中建立你的影响力和号召力，这可以让你在职场发展过程，持续增加个人溢价和商业潜力。</p><h2 id="4-建立连接"><a href="#4-建立连接" class="headerlink" title="4. 建立连接"></a>4. 建立连接</h2><p>我的写作期初只是为了记录自己的成长收获，我却意外的获得了： 前辈的鼓励、很多同龄大学生的共鸣、潜在雇主的实习机会、合作伙伴的邀约、创业合伙人的结缘、客户资源的获取…… 事实上，远远不止这些。我这些年最知心的朋友和伙伴，都潜移默化的因为我的博客的存在而使得我们自然相吸，每每很多朋友一见如故，让我觉得世界上另一端还有如此多和我志同道合的朋友，我做什么都不会孤独，我做什么都会得到大家的帮助与支持。 连接力作为21世纪最重要的能力之一，我想没有什么能比持续写作更容易帮助你提升这种能力了。</p><h2 id="5-塑造品牌"><a href="#5-塑造品牌" class="headerlink" title="5. 塑造品牌"></a>5. 塑造品牌</h2><p>人的一生都在经营品牌，你信奉的人生哲学、你所追求的使命、你追求的价值观、你的品位和风格、你的为人处世、你的态度，这些都构成你作为一个品牌的要素。 文如其人，你的文字表达是让别人认识你的绝佳方式，透过文字的阅读，可以了解你是一个专业的、细腻的、幽默的、胸怀天下的、消极的、执着的、乃至有爱的独立生命个体。 个人品牌的经营的确需要付诸非常人的努力和坚持，方能发挥其影响力。</p><h2 id="6-动态简历"><a href="#6-动态简历" class="headerlink" title="6. 动态简历"></a>6. 动态简历</h2><p>纸质的简历只是一张干巴巴的纸，然而博客则是一个会讲故事经纪人。 今天所有的HR都喜欢这样的人才：</p><ol><li>善于学习的（读书笔记、实践观察）；</li><li>热爱分享的（分享工作实践经验）；</li><li>坚持不懈的（每天写一篇网络日志）；</li><li>营销自我的（开博客做个人品牌）；</li><li>连接能力强（通过网络拓展人脉资源）。</li></ol><p>而这一切，都可以通过一个博客实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog.jpg&quot; alt=&quot;blog&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;不管你是谁，都应该现在开始经营你的个人博客。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="自我认知" scheme="https://snaildev.github.io/categories/%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="随手写写" scheme="https://snaildev.github.io/tags/%E9%9A%8F%E6%89%8B%E5%86%99%E5%86%99/"/>
    
  </entry>
  
</feed>
