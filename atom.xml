<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SnailDev&#39;s Blog</title>
  
  <subtitle>简单不想写，太难不会写。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://snaildev.github.io/"/>
  <updated>2018-09-01T01:38:15.433Z</updated>
  <id>https://snaildev.github.io/</id>
  
  <author>
    <name>SnailDev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是H.265</title>
    <link href="https://snaildev.github.io/article/%E4%BB%80%E4%B9%88%E6%98%AFH.265.html"/>
    <id>https://snaildev.github.io/article/什么是H.265.html</id>
    <published>2018-07-16T02:26:00.000Z</published>
    <updated>2018-09-01T01:38:15.433Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/h.265_1.jpg" alt="xh265-vid-top jpg pagespeed gp jp jw pj ws js rj rp rw ri cp md ic saoisp96-x"></p><p>最近偶然读了一篇文章<a href="https://mp.weixin.qq.com/s/z5y4NUr_lE_cY6FMSaIRUw" rel="external nofollow noopener noreferrer" target="_blank">一位女运维的自述：3年为公司节省10亿元！</a>，大意是腾讯运维如何运用图像影音压缩技术为公司和用户节省了大量流量，节约了成本并提高了用户体验。其中关键技术 <strong><em>H.265</em></strong> 吸引了我的注意，于是百谷歌度了一番，做了一个大致的了解。</p><a id="more"></a><p><a href="https://www.howtogeek.com/206662/should-you-get-an-ultra-hd-4k-tv/" rel="external nofollow noopener noreferrer" target="_blank">4K is the next big thing in TVs</a>, 和 <a href="https://www.howtogeek.com/300847/where-can-you-find-4k-video-for-your-4k-tv/" rel="external nofollow noopener noreferrer" target="_blank">4K videos are starting to pop up everywhere</a>. 但由于4K视频占用了大量的空间，很难以最佳质量进行下载和流式传输，而值得庆幸的是，一种被称为高效视频编码技术（High Efficiency Video Coding (HEVC), or H.265）正在改变这种情况。</p><p>这项新技术还需要很长一段时间才能得到大范围的应用，目前它正出现在—4K UHD Blu-rays 使用 HEVC, <a href="https://www.videolan.org/vlc/releases/3.0.0.html" rel="external nofollow noopener noreferrer" target="_blank">VLC 3.0</a>使得你PC机上的HEVC 和 4K 视频更加清晰，iPhone 设备甚至可以用HEVC技术记录视频以节约存储空间。但它是如何工作的，为什么对4K视频如此重要？</p><h2 id="1-当前标准：AVC-H-264"><a href="#1-当前标准：AVC-H-264" class="headerlink" title="1. 当前标准：AVC / H.264"></a>1. 当前标准：AVC / H.264</h2><p>当你观看蓝光光盘，YouTube视频或者来自ITunes的电影时，它与来自编辑室的原始视频不是完全相同的。为了是该电影或者视频更适合蓝光光盘——或者使其足够小以便在网上轻松下载——必须对电影压缩。 高级视频编码也被称为AVC或H.264,是广泛使用的视频压缩的最佳标准，并且有几种不同的方法可用于减小视频文件的大小。 例如，在任何给定的帧中，它可以查找大多数颜色相同的区域。在我和我儿子的这幅禁止帧中——大部分的天空都是相同的蓝色，因此压缩算法可以将图像分割成块——称之为“macroblocks”——并表明“我们仅仅假设沿着顶部的所有这些块都是相同的蓝色以替代记录每个像素的颜色”。这比存储每个单独像素的颜色效率更高，降低最终图像的文件大小。在视频中， 该技术被称之为帧内压缩——压缩单个帧的数据。</p><p><img src="/images/h.265_2.jpg" alt="img_1617-1"></p><p>AVC还使用帧间压缩，它可以查看多个帧并记录帧的哪些部分正在改变 - 哪些不是。从“美国队长：内战”中获得这一镜头。 背景并没有太大的变化 - 帧之间的差异大部分来自钢铁侠的脸部和身体。 所以，压缩算法可以将帧分成相同的宏块，并表明“你知道什么？ 这些块不会改变100帧，所以让我们再次显示它们，而不是将整个图像存储100次。“这可以显著减小文件大小。</p><p><img src="/images/h.265_3.gif" alt="5af0120085a6c_5af012009aeab"></p><p>这些只是AVC / H.264使用方法的两个过度简化的例子，但您清楚了其中的原理。 这完全是为了在不影响质量的情况下提高视频文件的效率。 （当然，如果压缩太多，任何视频都会失去质量，但这些技术越聪明，在您进入该点之前就可以压缩越多。）</p><h2 id="2-HEVC-H-265更高效地压缩视频，非常适合4K视频"><a href="#2-HEVC-H-265更高效地压缩视频，非常适合4K视频" class="headerlink" title="2. HEVC / H.265更高效地压缩视频，非常适合4K视频"></a>2. HEVC / H.265更高效地压缩视频，非常适合4K视频</h2><p>高效视频编码技术也称为HEVC或H.265，是视频编码技术演进的下一步。 它的构建使用了AVC / H.264中的许多技术，使视频压缩效率更高。</p><p>举个例子，当AVC查看多个帧变更时（例如上面的美国队长例子），这些宏块“块”可以是几个不同的形状和大小，最多可达16个像素乘16个像素。 而使用HEVC，这些块可以达到64×64的尺寸 - 远远大于16×16，这意味着该算法可以记忆更少的块，从而减小整体视频的尺寸。</p><p>您可以在<a href="https://www.youtube.com/channel/UCD80RKxQODrPv-PdM3Js8IQ" rel="external nofollow noopener noreferrer" target="_blank">HandyAndy Tech Tips</a>的这个精彩视频中看到对这项技术的更多技术性解释.</p><p>当然，HEVC还有其他一些技术正在运用，但这是最大的改进之一 - 当所有事情说到做到之后，HEVC可以在相同的质量水平下将视频压缩两倍于AVC。 对于用AVC技术编码而占用大量空间的4K视频而尤其重要。 HEVC使4K视频更容易流式传输，下载或翻录到硬盘。</p><h2 id="3-缺陷：HEVC在没有硬件加速解码的情况下很慢"><a href="#3-缺陷：HEVC在没有硬件加速解码的情况下很慢" class="headerlink" title="3. 缺陷：HEVC在没有硬件加速解码的情况下很慢"></a>3. 缺陷：HEVC在没有硬件加速解码的情况下很慢</h2><p>自2013年以来，HEVC一直是获批准的标准，那么为什么我们不能将它用于所有视频？ 相关： <a href="https://www.howtogeek.com/260784/how-to-make-vlc-use-less-battery-life-by-enabling-hardware-acceleration/" rel="external nofollow noopener noreferrer" target="_blank">如何通过启用硬件加速使VLC使用更少的电量</a> 这些压缩算法非常复杂 - 在视频播放之前，需要花费大量的数学计算才能实现解码。 计算机有两种主要的方式可以解码在这种视频：一软件解码，它会使用你的计算机的CPU来完成这个数学运算，或者二<a href="https://www.howtogeek.com/260784/how-to-make-vlc-use-less-battery-life-by-enabling-hardware-acceleration/" rel="external nofollow noopener noreferrer" target="_blank">硬件解码</a> ，在这个解码过程中，它将负载交给你的图形卡（或者你的集成图形芯片中央处理器）。 只要显卡支持所尝试播放的视频的编解码器，则效率更高。</p><p>因此，尽管许多PC和程序都可以尝试播放HEVC视频，但是如果没有硬件解码，它可能会卡顿或者非常慢。 所以，除非你有一个支持HEVC硬件解码的图形卡和视频播放器，否则HEVC对你来说并不是很好。</p><p>这对于独立播放设备来说不是问题 - 包括Xbox One在内的4K蓝光播放机都是以HEVC为基础构建的。 但是当谈到在PC上播放HEVC视频时，事情变得更加困难。 您的计算机将需要以下硬件之一才能硬解码HEVC视频：</p><ul><li>英特尔第六代“Skylake”或更新的CPU</li><li>AMD第六代“Carizzo”或更新的APU</li><li>NVIDIA GeForce GTX 950,960或更新的显卡</li><li>AMD Radeon R9 Fury，R9 Fury X，R9 Nano或更新的显卡</li></ul><p>您可能还需要使用不仅能支持HEVC视频，而且还支持HEVC硬件解码的操作系统和视频播放器 - 目前这有点多余。 许多玩家仍在增加对HEVC硬件解码的支持，并且在某些情况下，它可能仅适用于上面列表中的某些芯片。 在撰写本文时， <a href="https://www.videolan.org/" rel="external nofollow noopener noreferrer" target="_blank">VLC</a> 3.0， <a href="https://kodi.tv/" rel="external nofollow noopener noreferrer" target="_blank">Kodi</a> 17和<a href="https://www.plex.tv/" rel="external nofollow noopener noreferrer" target="_blank">Plex Media Server</a> 1.10都支持某种形式的HEVC硬件解码，至少对于某些卡而言。 不过，您可能必须在选择的播放器中<a href="https://www.howtogeek.com/260784/how-to-make-vlc-use-less-battery-life-by-enabling-hardware-acceleration/" rel="external nofollow noopener noreferrer" target="_blank">启用硬件加速</a>才能正常工作。</p><p>随着时间的推移，越来越多的计算机将能够处理这种视频，而更多的播放器将会更广泛地支持它 - 就像现在使用AVC / H.264一样。 它可能需要一段时间才会变得无处不在，在此之前，您必须以巨大的文件大小（或压缩它并丢失图像质量）将您的4K视频存储在AVC / H.264中。 但是，HEVC / H.265得到广泛支持越多，视频就越好。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><p>图片来源： <a href="https://www.shutterstock.com/image-photo/realism-sporting-images-broadcast-on-tv-725299213" rel="external nofollow noopener noreferrer" target="_blank">alphaspirit</a> /Shutterstock.com</p><p>本文翻译自：<a href="https://www.howtogeek.com/342416/what-is-hevc-h.265-video-and-why-is-it-so-important-for-4k-movies/" rel="external nofollow noopener noreferrer" target="_blank">What Is HEVC H.265 Video, and Why Is It So Important for 4K Movies?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/h.265_1.jpg&quot; alt=&quot;xh265-vid-top jpg pagespeed gp jp jw pj ws js rj rp rw ri cp md ic saoisp96-x&quot;&gt;&lt;/p&gt;&lt;p&gt;最近偶然读了一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s/z5y4NUr_lE_cY6FMSaIRUw&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;一位女运维的自述：3年为公司节省10亿元！&lt;/a&gt;，大意是腾讯运维如何运用图像影音压缩技术为公司和用户节省了大量流量，节约了成本并提高了用户体验。其中关键技术 &lt;strong&gt;&lt;em&gt;H.265&lt;/em&gt;&lt;/strong&gt; 吸引了我的注意，于是百谷歌度了一番，做了一个大致的了解。&lt;/p&gt;
    
    </summary>
    
      <category term="图像影音" scheme="https://snaildev.github.io/categories/%E5%9B%BE%E5%83%8F%E5%BD%B1%E9%9F%B3/"/>
    
    
      <category term="随手写写" scheme="https://snaildev.github.io/tags/%E9%9A%8F%E6%89%8B%E5%86%99%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>Consul服务治理</title>
    <link href="https://snaildev.github.io/article/Consul%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86.html"/>
    <id>https://snaildev.github.io/article/Consul服务治理.html</id>
    <published>2018-05-09T09:53:00.000Z</published>
    <updated>2018-09-01T01:38:15.403Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/consul.jpg" alt="consul"></p><p>Consul是google开源的一个使用go语言开发的服务发现、配置管理中心服务。内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（如ZooKeeper等）。服务部署简单，只有一个可运行的二进制的包。每个节点都需要运行agent，他有两种运行模式server和client。每个数据中心官方建议需要3或5个server节点以保证数据安全，同时保证server-leader的选举能够正确的进行。<a id="more"></a></p><ul><li><p>client</p><p>client表示Consul的client模式，就是客户端模式。是Consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到server，本身是不持久化这些信息。</p></li><li><p>server</p><p>server表示Consul的server模式，表明这个Consul是个server，这种模式下，功能和client都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。</p></li><li><p>server-leader</p><p>中间那个server下面有leader的字眼，表明这个server是它们的老大，它和其它server不一样的一点是，它需要负责同步注册的信息给其它的server，同时也要负责各个节点的健康监测。</p></li><li><p>raft</p><p>server节点之间的数据一致性保证，一致性协议使用的是raft，而zookeeper用的paxos，etcd采用的也是taft。</p></li><li><p>服务发现协议</p><p>Consul采用http和dns协议，etcd只支持http</p></li><li><p>服务注册</p><p>Consul支持两种方式实现服务注册，一种是通过Consul的服务注册http API，由服务自己调用API实现注册，另一种方式是通过json个是的配置文件实现注册，将需要注册的服务以json格式的配置文件给出。Consul官方建议使用第二种方式。</p></li><li><p>服务发现</p><p>Consul支持两种方式实现服务发现，一种是通过http API来查询有哪些服务，另外一种是通过Consul agent 自带的DNS（8600端口），域名是以NAME.service.consul的形式给出，NAME即在定义的服务配置文件中，服务的名称。DNS方式可以通过check的方式检查服务。</p></li><li><p>服务间的通信协议</p><p>Consul使用gossip协议管理成员关系、广播消息到整个集群，他有两个gossip pool（LAN pool和WAN pool），LAN pool是同一个数据中心内部通信的，WAN pool是多个数据中心通信的，LAN pool有多个，WAN pool只有一个。</p></li></ul><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>首先去官网现在合适的consul包：<a href="https://www.consul.io/downloads.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.consul.io/downloads.html</a> 安装直接下载zip包，解压后只有一个可执行的文件consul，将consul添加到系统的环境变量里面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#unzip consul_1.0.2_linux_amd64.zip</span></span><br><span class="line"><span class="comment">#cp -a consul  /usr/bin</span></span><br><span class="line"><span class="comment">#consul</span></span><br></pre></td></tr></table></figure><p></p><p><img src="/images/consul_1.png" alt="1200972-20180104111330034-1408661682"></p><p>出现上面的内容证明安装成功。</p><h2 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h2><p>consul必须启动agent才能使用，有两种启动模式server和client，还有一个官方自带的ui。server用与持久化服务信息，集群官方建议3或5个节点。client只用与于server交互。ui可以查看集群情况的。</p><p><strong>Server</strong></p><p>cn1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent -bootstrap-expect 2 -server -data-dir /data/consul0 -node=cn1 -bind=192.168.1.202 -config-dir /etc/consul.d -enable-script-checks=true -datacenter=dc1</span></span><br></pre></td></tr></table></figure><p></p><p>cn2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent -server  -data-dir /data/consul0 -node=cn2 -bind=192.168.1.201 -config-dir /etc/consul.d -enable-script-checks=true -datacenter=dc1 -join 192.168.1.202</span></span><br></pre></td></tr></table></figure><p></p><p>cn3:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent -server -data-dir /data/consul0 -node=cn3 -bind=192.168.1.200 -config-dir /etc/consul.d -enable-script-checks=true -datacenter=dc1 -join 192.168.1.202</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>参数解释：</p><ul><li>-bootstrap-expect： 集群期望的节点数，只有节点数量达到这个值才会选举leader。</li><li>-server： 运行在server模式</li><li>-data-dir：指定数据目录，其他的节点对于这个目录必须有读的权限</li><li>-node：指定节点的名称</li><li>-bind：为该节点绑定一个地址</li><li>-config-dir：指定配置文件，定义服务的，默认所有一.json结尾的文件都会读</li><li>-enable-script-checks=true：设置检查服务为可用</li><li>-datacenter： 数据中心没名称，</li><li>-join：加入到已有的集群中</li></ul></blockquote><p><strong>Client</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent   -data-dir /data/consul0 -node=cn4 -bind=192.168.1.199 -config-dir /etc/consul.d -enable-script-checks=true  -datacenter=dc1  -join 192.168.1.202</span></span><br></pre></td></tr></table></figure><p></p><p>client节点可以有多个，自己根据服务指定即可。</p><p><strong>UI</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent  -ui  -data-dir /data/consul0 -node=cn4 -bind=192.168.1.198  -client 192.168.1.198   -config-dir /etc/consul.d -enable-script-checks=true  -datacenter=dc1  -join 192.168.1.202</span></span><br></pre></td></tr></table></figure><p></p><blockquote><ul><li>-ui：使用自带的ui，</li><li>-ui-dir：指定ui的目录，使用自己定义的ui</li><li>-client：指定web ui、的监听地址，默认127.0.0.1只能本机访问。</li></ul></blockquote><p>集群创建完成后，可以使用一些常用的命令检查集群的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul  info</span></span><br></pre></td></tr></table></figure><p></p><p>可以在raft：stat看到此节点的状态是fllower或者leader</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul members</span></span><br><span class="line"></span><br><span class="line">Node Address Status Type Build Protocol DC Segment</span><br><span class="line">cn1 192.168.1.202:8301 alive server 1.0.2 2 dc1 &lt;all&gt;</span><br><span class="line">cn2 192.168.1.201:8301 alive server 1.0.2 2 dc1 &lt;all&gt;</span><br><span class="line">cn3 192.168.1.200:8301 alive client 1.0.2 2 dc1 &lt;default&gt;</span><br></pre></td></tr></table></figure><p></p><p>新加入一个节点有几种方式:</p><ol><li><p>这种方式，重启后不会自动加入集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul  join  192.168.1.202</span></span><br></pre></td></tr></table></figure></li><li><p>在启动的时候使用-join指定一个集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent  -ui  -data-dir /data/consul0 -node=cn4 -bind=192.168.1.198 -config-dir /etc/consul.d -enable-script-checks=true  -datacenter=dc1  -join 192.168.1.202</span></span><br></pre></td></tr></table></figure></li><li><p>使用-startjoin或-rejoin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#consul agent  -ui  -data-dir /data/consul0 -node=cn4 -bind=192.168.1.198 -config-dir /etc/consul.d -enable-script-checks=true  -datacenter=dc1  -rejoin</span></span><br></pre></td></tr></table></figure></li></ol><p>访问ui: <a href="http://192.168.1.198:8500/ui" rel="external nofollow noopener noreferrer" target="_blank">http://192.168.1.198:8500/ui</a></p><blockquote><p>端口： 8300：consul agent服务relplaction、rpc（client-server） 8301：lan gossip 8302：wan gossip 8500：http api端口 8600：DNS服务端口</p></blockquote><h2 id="3-服务注册"><a href="#3-服务注册" class="headerlink" title="3. 服务注册"></a>3. 服务注册</h2><p>采用的是配置文件的方式，（官方推荐）首先创建一个目录用于存放定义服务的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mkdir /etc/consul.d/</span></span><br></pre></td></tr></table></figure><p></p><p>启动服务的时候要使用-config-dir 参数指定。</p><p>下面给出一个服务定义：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat web.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"service"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"web"</span>,</span><br><span class="line">    <span class="string">"tags"</span>: [<span class="string">"rails"</span>],</span><br><span class="line">    <span class="string">"port"</span>: 80,</span><br><span class="line">    <span class="string">"check"</span>: &#123;</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"ping"</span>,</span><br><span class="line">      <span class="string">"script"</span>: <span class="string">"curl -s localhost:80"</span>,</span><br><span class="line">      <span class="string">"interval"</span>: <span class="string">"3s"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>启动后就可以在没有运行web服务的机器上面执行DNS查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dig @127.0.0.1 -p 8600 web.service.consul SRV</span></span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">web.service.consul.0INSRV1 1 80 cn2.node.dc1.consul.</span><br><span class="line">web.service.consul.0INSRV1 1 80 cn3.node.dc1.consul.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">cn2.node.dc1.consul.0INA192.168.1.201</span><br><span class="line">cn2.node.dc1.consul.0INTXT<span class="string">"consul-network-segment="</span></span><br><span class="line">cn3.node.dc1.consul.0INA192.168.1.200</span><br><span class="line">cn3.node.dc1.consul.0INTXT<span class="string">"consul-network-segment="</span></span><br><span class="line"></span><br><span class="line">;; Query time: 17 msec</span><br><span class="line">;; SERVER: 127.0.0.1<span class="comment">#8600(127.0.0.1)</span></span><br><span class="line">;; WHEN: 四 1月 04 14:39:32 CST 2018</span><br><span class="line">;; MSG SIZE rcvd: 229</span><br></pre></td></tr></table></figure><p></p><p>可以看到服务已经注册到集群里面了。 使用dns查询，默认域名格式NAME.service.consul，NAME就是web.json里面定义的service的name。可以自己指定域和端口：-domain、-dns-port 53</p><h2 id="4-健康检查"><a href="#4-健康检查" class="headerlink" title="4. 健康检查"></a>4. 健康检查</h2><p>check使用来做服务的健康检查的，可以拥有多个，也可以不使用支持多种方式检查。check必须是script或者TTL类型的，如果是script类型则script和interval变量必须被提供，如果是TTL类型则ttl变量必须被提供。script是consul主动去检查服务的健康状况，ttl是服务主动向consul报告自己的状况。</p><ul><li><p>script check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"check"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: mutil - memory,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"memory utilization"</span>,</span><br><span class="line">    <span class="string">"tags"</span>: [<span class="string">"system"</span>],</span><br><span class="line">    <span class="string">"script"</span>: <span class="string">"/etc/init.d/check_memory.py"</span>,</span><br><span class="line">    <span class="string">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>http check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"check"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"api"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"HTTP API  500"</span>,</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://loclhost:500/health"</span>,</span><br><span class="line">    <span class="string">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>tcp check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"check"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"ssh"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ssh TCP 26622"</span>,</span><br><span class="line">    <span class="string">"tcp"</span>: <span class="string">"localhost:26622"</span>,</span><br><span class="line">    <span class="string">"interval"</span>: <span class="string">"10s"</span>,</span><br><span class="line">    <span class="string">"timeout"</span>: <span class="string">"1s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ttl check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"check"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"web-app"</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Web APP status"</span>,</span><br><span class="line">    <span class="string">"notes"</span>: <span class="string">"Web APP does a curl  internally every 10 seconds"</span>,</span><br><span class="line">    <span class="string">"ttl"</span>: <span class="string">"30s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>全文完</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/consul.jpg&quot; alt=&quot;consul&quot;&gt;&lt;/p&gt;&lt;p&gt;Consul是google开源的一个使用go语言开发的服务发现、配置管理中心服务。内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（如ZooKeeper等）。服务部署简单，只有一个可运行的二进制的包。每个节点都需要运行agent，他有两种运行模式server和client。每个数据中心官方建议需要3或5个server节点以保证数据安全，同时保证server-leader的选举能够正确的进行。
    
    </summary>
    
      <category term="Consul" scheme="https://snaildev.github.io/categories/consul/"/>
    
      <category term="SOA" scheme="https://snaildev.github.io/categories/consul/soa/"/>
    
      <category term="微服务" scheme="https://snaildev.github.io/categories/consul/soa/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="服务注册及发现" scheme="https://snaildev.github.io/categories/consul/soa/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%8A%E5%8F%91%E7%8E%B0/"/>
    
    
      <category term="Consul" scheme="https://snaildev.github.io/tags/consul/"/>
    
      <category term="SOA" scheme="https://snaildev.github.io/tags/soa/"/>
    
      <category term="微服务" scheme="https://snaildev.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="服务注册及发现" scheme="https://snaildev.github.io/tags/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%8F%8A%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>高性能js库Lodash</title>
    <link href="https://snaildev.github.io/article/%E9%AB%98%E6%80%A7%E8%83%BDjs%E5%BA%93Lodash.html"/>
    <id>https://snaildev.github.io/article/高性能js库Lodash.html</id>
    <published>2018-05-08T03:09:00.000Z</published>
    <updated>2018-09-01T01:38:15.441Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/lodash_0.jpg" alt="timg"></p><p>有几年开发经验的工程师，往往都会有自己的一套工具库，称为utils、helpers等等，这套库一方面是自己的技术积累，另一方面也是对某项技术的扩展，领先于技术规范的制订和实现。 Lodash就是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前ECMAScript尚未制订的规范，但同时被业界所认可的辅助函数。而且每天使用npm安装Lodash的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。<a id="more"></a></p><h2 id="1-模块组成"><a href="#1-模块组成" class="headerlink" title="1. 模块组成"></a>1. 模块组成</h2><ul><li>Lodash听得辅助函数主要分为以下几类，函数列表和用法实力请查看Lodash的官方文档：</li><li>Array， 适合于数组类型，比如填充数据、查找元素、数组分片等操作</li><li>Collocation， 适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作</li><li>Function， 适用于函数类型，比如节流、延迟、缓存、设置钩子等操作</li><li>Lang， 普遍适用于各种类型，常用于执行类型判断和类型转换</li><li>Math， 使用与数值类型，常用于执行数学运算</li><li>Number， 适用于生成随机数，比较数值与数值区间的关系</li><li>Object， 适用于对象类型，常用于对象的创建、扩展、类型转换、检索、集合等操作</li><li>Seq， 常用于创建链式调用，提高执行性能（惰性计算）</li><li>String， 适用于字符串类型</li><li>lodash/fp 模块提供了更接近函数式编程的开发方法，其内部的函数经过包装，具有immutable、auto-curried、iteratee-first、data-last（官方介绍）等特点。</li><li>Fixed Arity，固化参数个数，便于柯里化</li><li>Rearragned Arguments， 重新调整参数位置，便于函数之间的聚合</li><li>Capped Iteratee Argument， 封装Iteratee参数</li></ul><h2 id="1-性能"><a href="#1-性能" class="headerlink" title="1. 性能"></a>1. 性能</h2><p>在 Filip Zawada的文章<a href="https://link.jianshu.com/?t=http://filimanjaro.com/blog/2014/introducing-lazy-evaluation/" rel="external nofollow noopener noreferrer" target="_blank">《How to Speed Up Lo-Dash ×100? Introducing Lazy Evaluation》</a>中提到了Lodash提高执行速度的思路，主要有三点： Lazy Evaluation、Pipelining和Deferred Execution。下面两张图来自Filip的博客：</p><p><img src="/images/lodash_1.gif" alt="976007-20180123132259975-836139498"></p><p>假设有如上图所示的问题： 从若干个求中取出三个面值小于10的球。第一步是从所有的求中取出所有面值小于10的球，第二部是从上一步的结果中去三个球。</p><p><img src="/images/lodash_2.gif" alt="976007-20180123132320240-161059187"></p><p>上图是另一个解决方案，如果一个球能够通过第一步，那么就继续执行第二步，直至结束然后测试下一个球。。。当我们取到三个球之后就中断整个循环。Filip称这是Lazy Evaluation Algorithm， 就个人理解这并不全面，他后续提到的Pipelining（管道计算），再加上一个中断循环执行的算法应该更符合这里的图示。</p><p>此外，使用Lodash的链式调用时，只有现实或隐式调用 .value 方法才会对链式调用的整个操作进行取值，这种不在声明时立即求值，而在使用时进行求职的方式，是Lazy Evaluation最大的特点。</p><h2 id="3-九个实例"><a href="#3-九个实例" class="headerlink" title="3. 九个实例"></a>3. 九个实例</h2><p>收益于Lodash的普及程度，使用它可以提高很多人开发时于都代码的效率，减少彼此之间的误解（Loss of Consciousness）。在<a href="https://link.jianshu.com/?t=http://colintoh.com/blog/lodash-10-javascript-utility-functions-stop-rewriting" rel="external nofollow noopener noreferrer" target="_blank">《Lodash: 10 Javascript Utility Functions That You Should Probably Stop Rewriting》</a>一文中，作者列举了多个常用的Lodash函数，实例演示了使用Lodash的技巧。</p><ol><li>N次循环</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Basic for loop.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Using Array's join and split methods</span></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">Array</span>(<span class="number">5</span>)).forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.times(<span class="number">5</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>for 语句是执行虚幻的不二选择，Array.apply也可以模拟循环，但在上面代码的使用场景下，_.tiems()的解决方法更加简洁和易于理解。</p><ol start="2"><li>深层查找属性值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the name of the first pet from each owner</span></span><br><span class="line"><span class="keyword">var</span> ownerArr = [&#123;</span><br><span class="line">    <span class="string">"owner"</span>: <span class="string">"Colin"</span>,</span><br><span class="line">    <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog1"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog2"</span>&#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">"owner"</span>: <span class="string">"John"</span>,</span><br><span class="line">    <span class="string">"pets"</span>: [&#123;<span class="string">"name"</span>: <span class="string">"dog3"</span>&#125;, &#123;<span class="string">"name"</span>: <span class="string">"dog4"</span>&#125;]</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array's map method.</span></span><br><span class="line">ownerArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">owner</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> owner.pets[<span class="number">0</span>].name;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.map(ownerArr, <span class="string">"pets[0].name"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>_.map 方法是对原生 map 方法的改进，其中使用 pets[0].name 字符串对嵌套数据取值的方式简化了很多冗余的代码，非常类似使用jQuery选择DOM节点 ul&gt;li&gt;a , 对于前端开发者来说有种久违的亲切感。</p><ol start="3"><li>个性化数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array's map method.</span></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">Array</span>(<span class="number">6</span>)).map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ball_"</span> + index; </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.times(<span class="number">6</span>, _.uniqueId.bind(<span class="literal">null</span>, <span class="string">'ball_'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.times(<span class="number">6</span>, _.partial(_.uniqueId, <span class="string">'ball_'</span>));</span><br><span class="line"><span class="comment">// eg. [ball_0, ball_1, ball_2, ball_3, ball_4, ball_6]</span></span><br></pre></td></tr></table></figure></li></ol><p>在上面的代码中，我们要创建一个初始值不同、长度为6的数组，其中 _.uniqueId 方法用于生成独一无二的标示符（递增的数字，在程序运行期间保持独一无二）， _.partial 方法是对 bind 的封装。</p><ol start="4"><li>深拷贝<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"colin"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用的方法一般会比较长，循环对象等</span></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/4459928/how-to-deep-clone-in-javascript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line"><span class="keyword">var</span> objB = _.cloneDeep(objA);</span><br><span class="line">objB === objA <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ol><p>JavaScript 没有直接提供深拷贝的函数，但是我们可以用其他杉树来模拟，比如 JSON.parse(JSON.stringify(objectToClone)), 但这种方法要求对象中的属性值不能是函数。Lodash 中的 _.cloneDeep 函数封装了深拷贝的逻辑，用起来更加简洁。</p><ol start="5"><li>随机数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native utility method</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomNumber</span>(<span class="params">min, max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>)) + min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getRandomNumber(<span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.random(<span class="number">15</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ol><p>Lodash 的随机数生成函数更贴近实际开发，ECMAScript 的随机数生成函数式底层必备的接口，两者都不可获取。此外，使用 _.random(15, 20, true) 还可以在15到20之间生成随机的浮点数。</p><ol start="6"><li>对象扩展<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adding extend function to Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(i)) &#123;</span><br><span class="line">            <span class="keyword">this</span>[i] = obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"colin"</span>, <span class="string">"car"</span>: <span class="string">"suzuki"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> objB = &#123;<span class="string">"name"</span>: <span class="string">"james"</span>, <span class="string">"age"</span>: <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line">objA.extend(objB);</span><br><span class="line">objA; <span class="comment">// &#123;"name": "james", "age": 17, "car": "suzuki"&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.assign(objA, ojbB);</span><br></pre></td></tr></table></figure></li></ol><p>_.assign 是浅拷贝， 和ES6新增的 Object.assign 函数功能一致（建议优先使用Object.assign）。</p><ol start="7"><li>筛选属性<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native method: Remove an array of keys from object</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.remove = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">delete</span>(<span class="keyword">this</span>[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"colin"</span>, <span class="string">"car"</span>: <span class="string">"suzuki"</span>, <span class="string">"age"</span>: <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line">objA.remove([<span class="string">'car'</span>, <span class="string">'age'</span>]);</span><br><span class="line">objA; <span class="comment">// &#123;"name": "colin"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">objA = _.omit(objA, [<span class="string">'car'</span>, <span class="string">'age'</span>]);</span><br><span class="line"><span class="comment">// =&gt; &#123;"name": "colin"&#125;</span></span><br><span class="line"></span><br><span class="line">objA = _.omit(objA, <span class="string">"car"</span>);</span><br><span class="line"><span class="comment">// =&gt; &#123;"name": "colin", "age": 17&#125;</span></span><br><span class="line"></span><br><span class="line">objA = _.omit(objA, _.isNumber);</span><br><span class="line"><span class="comment">// =&gt; &#123;"name": "colin", "car": "suzuki"&#125;;</span></span><br></pre></td></tr></table></figure></li></ol><p>大多数情况下，Lodash所提供的辅助函数都会比原声的函数更贴近开发需求。在上面的代码中，开发者可以使用数组、字符串以及函数的方式筛选对象的属性，并且最终会返回一个新的对象，中间执行筛选时不会对旧对象产生影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native method: Returning a new object with selected properties</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.pick = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        obj[key] = _this[key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = &#123;<span class="string">"name"</span>: <span class="string">"colin"</span>, <span class="string">"car"</span>: <span class="string">"suzuki"</span>, <span class="string">"age"</span>: <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objB = objA.pick([<span class="string">'car'</span>, <span class="string">'age'</span>]);</span><br><span class="line"><span class="comment">// =&gt; &#123;"car": "suzuki", "age": 17&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line"><span class="keyword">var</span> objB = _.pick(objA, [<span class="string">'car'</span>, <span class="string">'age'</span>]);</span><br><span class="line"><span class="comment">// =&gt; &#123;"car": "suzuki", "age":17&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>_.pick 是 _.omit 的相反操作，用于从其他对象中挑选属性生成新的对象。</p><ol start="8"><li>随机元素<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> luckDraw = [<span class="string">"Colin"</span>, <span class="string">"John"</span>, <span class="string">"James"</span>, <span class="string">"Lily"</span>, <span class="string">"Mary"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickRandomPerson</span>(<span class="params">luckyDraw</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (luckyDraw.length - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> luckyDraw[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pickRandomPerson(luckyDraw); <span class="comment">//John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash</span></span><br><span class="line">_.sample(luckyDraw); <span class="comment">// Colin</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lodash - Getting 2 random item</span></span><br><span class="line">_.sample(luckyDraw, <span class="number">2</span>); <span class="comment">// ['John', 'Lily']</span></span><br></pre></td></tr></table></figure></li></ol><p>_.sample 支持随机挑选多个元素并返回新的数组。</p><ol start="9"><li>针对 JSON.parse 的错误处理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using try-catch to handle the JSON.parse error</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// With Lodash</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseLodash</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.attempt(<span class="built_in">JSON</span>.parse.bind(<span class="literal">null</span>, str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parse(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line">parseLodash(<span class="string">'a'</span>);</span><br><span class="line"><span class="comment">// =&gt; Return an error object</span></span><br><span class="line"></span><br><span class="line">parse(<span class="string">'&#123;"name": "colin"&#125;'</span>);</span><br><span class="line"><span class="comment">// =&gt; Return &#123;"name": "colin"&#125;</span></span><br><span class="line">parseLodash(<span class="string">'&#123;"name": "colin"&#125;'</span>);</span><br><span class="line"><span class="comment">// =&gt; Return &#123;"name": "colin"&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>如果你在使用 JSON.parse 时没有预置错误处理，那么它很有可能会成为一个定时炸弹，我们不应该默认接收的JSON对象都是有效的。 try-catch 是常见的错误处理方式，如果项目中使用Lodash，那么可以使用 _.attmpt 替代 try-catch 的方式，当解析JSON出错时，该方法会返回一个 Error 对象。</p><blockquote><p>随着ES6的普及，Lodash的功能或多或少会被原生功能所替代，所以使用时还需要进一步甄别，建议优先使用原生函数，有关ES6替代Lodash的部分，请参考文章<a href="https://link.jianshu.com/?t=http://www.zcfy.cc/article/10-lodash-features-you-can-replace-with-es6-467.html" rel="external nofollow noopener noreferrer" target="_blank">《10 个可用 ES6 替代的 Lodash 特性》</a>。</p></blockquote><p>其中有两处分别值得一看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用箭头函数创建可复用的路径</span></span><br><span class="line"><span class="keyword">const</span> object = &#123; <span class="string">'a'</span>: [&#123; <span class="string">'b'</span>: &#123; <span class="string">'c'</span>: <span class="number">3</span> &#125; &#125;, <span class="number">4</span>] &#125;;</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    obj =&gt; obj.a[<span class="number">0</span>].b.c,</span><br><span class="line">    obj =&gt; ojb.a[<span class="number">1</span>]</span><br><span class="line">].map(<span class="function"><span class="params">path</span> =&gt;</span> path(object));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数编写链式调用</span></span><br><span class="line"><span class="keyword">const</span> pipe = <span class="function"><span class="params">function</span> =&gt;</span> data =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> functions.reduce(</span><br><span class="line">        (value, func) =&gt; func(value),</span><br><span class="line">        data</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pipeline = pipe([</span><br><span class="line">    x =&gt; x * <span class="number">2</span>,</span><br><span class="line">    x =&gt; x / <span class="number">3</span>,</span><br><span class="line">    x =&gt; x &gt; <span class="number">5</span>,</span><br><span class="line">    b =&gt; !b</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">pipeline(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">pipeline(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p></p><p>在ES6中，如果一个函数只接收一个形参且函数提示一个 return 语句， 就可以使用箭头函数简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">p</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于（不完全相同）</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当有多重嵌套时，可以简化为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="params">a</span> =&gt;</span> b =&gt; <span class="function"><span class="params">c</span> =&gt;</span> a + b + c;</span><br><span class="line">func(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/lodash_0.jpg&quot; alt=&quot;timg&quot;&gt;&lt;/p&gt;&lt;p&gt;有几年开发经验的工程师，往往都会有自己的一套工具库，称为utils、helpers等等，这套库一方面是自己的技术积累，另一方面也是对某项技术的扩展，领先于技术规范的制订和实现。 Lodash就是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前ECMAScript尚未制订的规范，但同时被业界所认可的辅助函数。而且每天使用npm安装Lodash的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。
    
    </summary>
    
      <category term="JavaScript" scheme="https://snaildev.github.io/categories/javascript/"/>
    
      <category term="Node,js" scheme="https://snaildev.github.io/categories/javascript/node-js/"/>
    
    
      <category term="JavaScript" scheme="https://snaildev.github.io/tags/javascript/"/>
    
      <category term="Node,js" scheme="https://snaildev.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>我的简历</title>
    <link href="https://snaildev.github.io/article/%E6%88%91%E7%9A%84%E7%AE%80%E5%8E%86.html"/>
    <id>https://snaildev.github.io/article/我的简历.html</id>
    <published>2018-03-08T13:09:00.000Z</published>
    <updated>2018-09-06T23:17:20.826Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/avatar_resume.jpg" alt="avatar"></p><a id="more"></a><p><a href="/files/java高级研发-赵明-黄山学院-猫酷科技-4年.pdf">打印入口</a></p><h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul><li>手机：15821753692（微信同号）</li><li>Email：<ul><li><a href="mailto:snailtem@gmail.com" rel="external nofollow noopener noreferrer" target="_blank">snailtem@gmail.com</a> （主）</li><li><a href="mailto:snaildev@outlook.com" rel="external nofollow noopener noreferrer" target="_blank">snaildev@outlook.com</a> （备）</li></ul></li><li>QQ：1397407698</li></ul><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>赵明/男/1990</li><li>本科/黄山学院 计算机科学与技术（2010/9–2014/7）</li><li>工作年限：<strong>4年</strong></li><li>技术博客：<ul><li><a href="https://snaildev.github.io">https://snaildev.github.io</a></li><li><a href="http://www.cnblogs.com/snaildev" target="_blank" rel="noopener">http://www.cnblogs.com/snaildev</a></li></ul></li><li>Github：<a href="https://github.com/snaildev" target="_blank" rel="noopener">https://github.com/snaildev</a></li><li>期望职位：Java高级程序员，应用架构师</li><li>期望薪资：税前月薪28k+</li><li>期望城市：上海</li></ul><h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h2 id="猫酷科技-（-2015年5月-至今-）"><a href="#猫酷科技-（-2015年5月-至今-）" class="headerlink" title="猫酷科技 （ 2015年5月 ~ 至今 ）"></a>猫酷科技 （ 2015年5月 ~ 至今 ）</h2><h3 id="猫酷车场"><a href="#猫酷车场" class="headerlink" title="猫酷车场"></a>猫酷车场</h3><p>实现功能：实现用户线上寻车，停车缴费等功能。</p><p>演进过程：</p><ol><li>接手：主导了猫酷车场2.0项目的研发，在1.0的基础上，对车场业务进行梳理，对上层业务代码进行封装，对底层接口对接进行开放，实现新车场接入不动上层业务代码。</li><li>改进：对接口对接层进行改进，实现配置化。第三方车场接口除了是http协议之外，也有不少是webservice/wcf这种soap协议的， 解决方式是通过抓包形式，实现报文配置的统一化。</li><li>持续改进：各个第三方接口的签名方式尽不相同，对接难免需要写代码实现，对于这种，解决方案是按照车场接口的厂商进行分类封装，重复对接同种厂商接口，仅需配置即可。</li><li>无感停车：接入支付宝车场，并开放车场相应功能（进出场通知，离场代扣）给到线下车场，使得车辆离场时不仅可以在使用会员权益、优惠券、积分后，还可以继续使用支付宝免密支付车费，无感出场。</li></ol><p>实现效果：系统更加稳定，用户体验更佳，对接成本从2人天降到0.5人天，目前车场平均月流水（多个商场合计）为800W左右</p><p>欢迎查阅：微信关注上海静安大悦城、近铁城市广场、上海环球港等可查看停车场功能。</p><h3 id="发布系统"><a href="#发布系统" class="headerlink" title="发布系统"></a>发布系统</h3><p>实现功能：实现代码发布、备份管理以及服务器管理等功能。</p><p>演进过程：</p><ol><li>接手分析：对发布各个流程进行分析，代码获取、代码编译、代码发布、生产环境备份、代码同步到目的服务器、 发布异常可回滚修复以及发布完成后进行接口测试等。<ul><li>代码获取（源代码管理器Git）</li><li>代码编译及发布（Java–&gt;Maven, .Net–&gt;MSBuild, .NetCore–&gt;dotnet，静态文件发布跳过编译过程）</li><li>服务器数据同步（rsync）</li><li>进行接口测试（Jmeter脚本）</li><li>发布结果推送给项目组成员（邮件通知）</li></ul></li><li>实践进行：服务器应该分环境，测试、仿真和正式。<ul><li>测试（研发发布，测试验证）</li><li>仿真（研发组长发布，研发和测试验证）</li><li>正式（就是生产环境，研发组长发布，仿真通过验证后，将仿真环境作为一个复制集同步到正式环境）</li></ul></li></ol><p>实现效果：规范了发布流程，解放了运维，使得公司约210个项目可使用发布系统稳定发布。</p><p>发布系统流程图： <img src="images/deploy.png" alt="deploy"></p><h3 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h3><ul><li>长益预付卡系统对接</li><li>微信小程序发布系统</li><li>Mongo2Es实时同步工具（<a href="https://github.com/SnailDev/SnailDev.Mongo2Es）" target="_blank" rel="noopener">https://github.com/SnailDev/SnailDev.Mongo2Es）</a></li><li>MongoDB Web端查询系统（<a href="https://github.com/SnailDev/SnailDev.MongoStudio）" target="_blank" rel="noopener">https://github.com/SnailDev/SnailDev.MongoStudio）</a></li><li>票据打印机ESC/POS指令解析（<a href="https://github.com/SnailDev/SnailDev.EscPosParser）" target="_blank" rel="noopener">https://github.com/SnailDev/SnailDev.EscPosParser）</a></li><li>NestRepository查询Es SDK封装（<a href="https://github.com/SnailDev/SnailDev.Mongo2Es/blob/master/README_NESTRepo.md）" target="_blank" rel="noopener">https://github.com/SnailDev/SnailDev.Mongo2Es/blob/master/README_NESTRepo.md）</a></li></ul><h2 id="博彦科技-（-2013年10月-2015年5月-含8个月实习）"><a href="#博彦科技-（-2013年10月-2015年5月-含8个月实习）" class="headerlink" title="博彦科技 （ 2013年10月 ~ 2015年5月 含8个月实习）"></a>博彦科技 （ 2013年10月 ~ 2015年5月 含8个月实习）</h2><h3 id="美国房贷系统"><a href="#美国房贷系统" class="headerlink" title="美国房贷系统"></a>美国房贷系统</h3><p>工作内容： 参与美国房贷系统Elliemae中WebCenter功能模块的开发和维护；即组长分配JIRA,然后根据JIRA上测试或者客户反馈的bug，进行复现，阅读源代码进行审查，修复bug，提交给组长Code Review。</p><p>开发模式： 敏捷开发，晚日报，晨站会</p><h3 id="内部日报系统"><a href="#内部日报系统" class="headerlink" title="内部日报系统"></a>内部日报系统</h3><p>工作内容：基于Asp.net MVC + Entity Framework + Bootstrap内部日报和请假系统的研发。</p><p>工作说明：由于项目组采用的是敏捷开发模式，每日站会和日报都是必须的，为了满足日报和请假的需求，定制了一套适合项目组内部的日报系统和请假系统。并结合了AlertSystem实现了成员日报邮件提醒。</p><h3 id="其他项目-1"><a href="#其他项目-1" class="headerlink" title="其他项目"></a>其他项目</h3><ul><li>培训考试系统</li><li>内部小工具（HostsHelper、FileFilter、IIsHelper等）</li><li>AlertSystem（基于WindowsService后台定时Email提醒服务）</li></ul><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟练使用的技能</p><ul><li>Web开发：Java/C#.Net/Node</li><li>Web框架：Spring/Asp.Net MVC/Express</li><li>前端框架：Bootstrap/Jquery/EasyUI/LigerUI/Vue</li><li>数据库相关：MySQL/MongoDB/Redis/ElasticSearch</li><li>版本管理：Svn/Git</li><li>单元测试：JUnit</li><li>云和开放平台：SAE/阿里云/腾讯云/微信应用开发</li></ul><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/avatar_resume.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="自我认知" scheme="https://snaildev.github.io/categories/%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="随手写写" scheme="https://snaildev.github.io/tags/%E9%9A%8F%E6%89%8B%E5%86%99%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>为什么要写博客</title>
    <link href="https://snaildev.github.io/article/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%9A%E5%AE%A2.html"/>
    <id>https://snaildev.github.io/article/为什么要写博客.html</id>
    <published>2017-06-15T02:26:00.000Z</published>
    <updated>2018-09-01T01:38:15.416Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/blog.jpg" alt="blog"></p><blockquote><p><strong>不管你是谁，都应该现在开始经营你的个人博客。</strong></p></blockquote><a id="more"></a><h2 id="1-深度思考"><a href="#1-深度思考" class="headerlink" title="1. 深度思考"></a>1. 深度思考</h2><p>书写是为了更好的思考，看到、知道并不一定掌握，只有通过文字，有条理和逻辑的呈现出来，你才算会真正的理解和掌握，而在写作的过程，你才会把曾经松散的思路和想法串联起来，形成系统的总结。</p><h2 id="2-沉淀想法"><a href="#2-沉淀想法" class="headerlink" title="2. 沉淀想法"></a>2. 沉淀想法</h2><p>俗话说，好记性不如烂笔头，必有其道理。因为想法和创意，瞬间即逝，当你想要二次查找或者给别人介绍的时候，你会发现记忆是多么的不靠谱，而只有日常的记录和写作才可以帮你随取、随用，而且好的想法，还可以刺激和影响更多人的新想法，通过他们的评论和分享，你的想法和创意将获得倍增。</p><h2 id="3-价值杠杆"><a href="#3-价值杠杆" class="headerlink" title="3. 价值杠杆"></a>3. 价值杠杆</h2><p>一个人的价值，在于其影响力。写作是一项低门槛、高回报——即高工作杠杆率——的事情。通过写作，你可以用最简单的方式持续积累个人影响力，尤其是通过专业主题领域的持续写作，让你在特定受众群体中建立你的影响力和号召力，这可以让你在职场发展过程，持续增加个人溢价和商业潜力。</p><h2 id="4-建立连接"><a href="#4-建立连接" class="headerlink" title="4. 建立连接"></a>4. 建立连接</h2><p>我的写作期初只是为了记录自己的成长收获，我却意外的获得了： 前辈的鼓励、很多同龄大学生的共鸣、潜在雇主的实习机会、合作伙伴的邀约、创业合伙人的结缘、客户资源的获取…… 事实上，远远不止这些。我这些年最知心的朋友和伙伴，都潜移默化的因为我的博客的存在而使得我们自然相吸，每每很多朋友一见如故，让我觉得世界上另一端还有如此多和我志同道合的朋友，我做什么都不会孤独，我做什么都会得到大家的帮助与支持。 连接力作为21世纪最重要的能力之一，我想没有什么能比持续写作更容易帮助你提升这种能力了。</p><h2 id="5-塑造品牌"><a href="#5-塑造品牌" class="headerlink" title="5. 塑造品牌"></a>5. 塑造品牌</h2><p>人的一生都在经营品牌，你信奉的人生哲学、你所追求的使命、你追求的价值观、你的品位和风格、你的为人处世、你的态度，这些都构成你作为一个品牌的要素。 文如其人，你的文字表达是让别人认识你的绝佳方式，透过文字的阅读，可以了解你是一个专业的、细腻的、幽默的、胸怀天下的、消极的、执着的、乃至有爱的独立生命个体。 个人品牌的经营的确需要付诸非常人的努力和坚持，方能发挥其影响力。</p><h2 id="6-动态简历"><a href="#6-动态简历" class="headerlink" title="6. 动态简历"></a>6. 动态简历</h2><p>纸质的简历只是一张干巴巴的纸，然而博客则是一个会讲故事经纪人。 今天所有的HR都喜欢这样的人才：</p><ol><li>善于学习的（读书笔记、实践观察）；</li><li>热爱分享的（分享工作实践经验）；</li><li>坚持不懈的（每天写一篇网络日志）；</li><li>营销自我的（开博客做个人品牌）；</li><li>连接能力强（通过网络拓展人脉资源）。</li></ol><p>而这一切，都可以通过一个博客实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/blog.jpg&quot; alt=&quot;blog&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;不管你是谁，都应该现在开始经营你的个人博客。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="自我认知" scheme="https://snaildev.github.io/categories/%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="随手写写" scheme="https://snaildev.github.io/tags/%E9%9A%8F%E6%89%8B%E5%86%99%E5%86%99/"/>
    
  </entry>
  
</feed>
